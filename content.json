{"meta":{"title":"一抹阳光 - qirenji.info","subtitle":"IT技术分享","description":"天才在于积累，聪明在于勤奋。","author":"Qi Renji","url":"http://www.qirenji.info"},"pages":[{"title":"关于我","date":"2017-08-28T14:14:19.000Z","updated":"2017-08-28T14:14:19.000Z","comments":false,"path":"about/index.html","permalink":"http://www.qirenji.info/about/index.html","excerpt":"","text":"简介姓名：齐仁吉 介绍：目前是一名待业码农，求工作，坐标北京 简历：👉我的简历 作品Vue.js打造的音乐播放器 👉预览地址 👉源码地址 👉博客地址 介绍vue学习项目，基于qq音乐API，完成音乐播放和搜索等功能。 技术栈 Vue2.0：前端页面展示。 Vue-cli：vue手脚架工具。 vue-router：页面路由切换。 axios：向后端发起请求。 Vuex：实现不同组件间的状态共享。 ES6：箭头函数等语法很好用。 localStorage：本地存储，保存歌单和个性化设置。 Express：后端调用qq音乐API，返回数据。 Webpack：vue-cli自带Webpack，添加sass相关loader，其他vue-cli已经配置好了webpack，你只需要安装依赖就可以，使用的时候只需要。 SASS(SCSS)：用SCSS做CSS预处理语言。 flex：flex弹性布局，简单适配手机、PC端。 CSS3：CSS3过渡动画及样式。 总结 深入学习vue.js全家桶，使用Vuex管理组件状态很方便。 事先要先想好整个页面结构和组件划分，方便快速开发。 继续完成歌词同步播放。 Vue.js开源的CNode社区 👉预览地址 👉源码地址 👉博客地址 介绍利用cnode社区提供的api实现，需去cnode个人中心登陆查看accesstoken才可以登录。 完成 首页列表，下拉加载 主题详情，回复，点赞 登录,退出 消息列表，消息提醒，消息标记为已读， 发布话题 技术栈 Vue2.0：前端页面展示。 Vue-cli：vue手脚架工具。 Vuex：实现不同组件间的状态共享。 vue-router：页面路由切换。 axios：向后端发起请求。 Socket.io：实现实时通信 Moment.js：格式化时间。 ES6：箭头函数等语法很好用。 localStorage：保存用户信息。 Webpack：vue-cli自带Webpack，添加sass相关loader，其他vue-cli已经配置好了webpack，你只需要安装依赖就可以，使用的时候只需要。 SASS(SCSS)：用SCSS做CSS预处理语言。 flex：flex弹性布局，简单适配手机、PC端。 CSS3：CSS3过渡动画及样式。 总结 深入学习vue.js全家桶，使用Vuex管理组件状态很方便。 事先要先想好整个页面结构和组件划分，方便快速开发。 Node.js + mongoDB + glup 搭建的电影网站 👉预览地址 👉源码地址 👉博客地址 介绍此项目是基于 Node.js + Express + mongoDB + Bootstrap + gulp 搭建的电影网站。 实现功能 [x] 前台电影展示页 [x] 电影详情页 [x] 后台电影管理中心（电影录入、电影修改） [x] 用户登录注册注销功能 [x] 后台用户管理中心（用户录入、用户修改） [x] 电影评论 [x] 电影分类管理（分类录入、修改） 技术栈【前端】 HTML/CSS/JS：亘古不变三件套 ES6：ECMAScript 新一代语法，这也是以后的趋势 Monment.js：时间日期格式化插件 jQuery：主要用到 jQuery 的 ajax 方法处理异步请求和 DOM 操作 Bootstrap：页面 UI 框架，天然响应式 用SCSS做CSS预处理语言。 【后端】 pug：pug (以前的 jade) 是一个高性能的模板引擎，用来生成 HTML Node.js：整个后端由 Node.js 驱动；用 npm 安装资源文件 Express：一个基于 Node.js 平台的 web 开发框架，由路由和中间件构成 【数据库】 mongoDB：进行数据存储的 NoSQL 数据库 【自动化构建】 gulp：前端自动化构建工具 【部署工具】 pm2: Node 应用的进程管理器。 总结 熟悉了 pug 的语法及其在 Node.js 中的使用方法 初步掌握了 express 框架的使用，如何处理路由以及中间件 掌握了 mongoose 在 Node.js 中如何连接数据库，以及 schema、model 的使用 前后端数据传递与视图展现的流程 学会了使用 bcryptjs（Node.js 的一个加解密模块）对密码进行 “hash + salt” 处理 借助会话与 cookie 进行用户识别和持久化 Vue.js打造的GitHub排行榜 👉预览地址 👉源码地址 👉博客地址 介绍爬虫简单小练习，利用Node js对github项目进行爬虫，对github各种类项目进行按🌟star数目进行排序。 实现功能 [x] github爬取 – 完成 [x] 项目主页显示 – 完成 [x] 项目切换 – 完成 技术栈 Vue2.0：前端页面展示。 Vue-cli：vue手脚架工具。 axios：向后端发起请求。 cheerio：快速、灵活、实施的jQuery核心实现，抓取页面内容很方便。 ES6：箭头函数、promise等语法很好用。 Webpack：vue-cli自带Webpack，添加sass相关loader，其他vue-cli已经配置好了webpack，你只需要安装依赖就可以，使用的时候只需要。 SASS(SCSS)：用SCSS做CSS预处理语言。 flex：flex弹性布局，简单适配手机、PC端。 CSS3：CSS3过渡动画及样式。 总结 每次现爬取github等待时间较长，可以使用缓冲，加快访问速度。使用json数据文件存到服务器，等有用户访问的时候读取该文件，活着使用redis缓存工具来解决此问题。 异步操作很好用，但也容易出错！熟练掌握Promis等方法，提高效率。 vue + socket.io智能聊天室 👉预览地址 👉源码地址 👉博客地址 实现功能 [x] 登录功能 – 完成 [x] 聊天功能 – 完成 [x] 多人聊天室 – 完成 [x] 与机器人聊天 – 完成 技术栈 Vue2.0：前端页面展示。 Vue-cli：vue手脚架工具。 Vuex：实现不同组件间的状态共享。 vue-router：页面路由切换。 axios：向后端发起请求。 Socket.io：实现实时通信 Express：实现后端socket.io监听功能。 Moment.js：格式化时间。 ES6：箭头函数等语法很好用。 localStorage：保存用户信息以及聊天记录。 Webpack：vue-cli自带Webpack，添加sass相关loader，其他vue-cli已经配置好了webpack，你只需要安装依赖就可以，使用的时候只需要。 SASS(SCSS)：用SCSS做CSS预处理语言。 flex：flex弹性布局，简单适配手机、PC端。 CSS3：CSS3过渡动画及样式。 总结socket.io 通过 emit 和 on 可以轻松地实现服务器与客户端之间的双向通信。 地区选择插件（三级联动） 简易日历组件 Css3翻书效果 Css3画廊效果 其他更多项目请登陆Github查看 https://github.com/qirenji/ About关于我: http://www.qirenji.info/about GitHub: https://github.com/qirenji/ E-mail: lyf@qirenji.com"},{"title":"","date":"2017-07-18T08:47:31.000Z","updated":"2017-07-18T08:47:31.000Z","comments":false,"path":"categories/index.html","permalink":"http://www.qirenji.info/categories/index.html","excerpt":"","text":""},{"title":"网络资料收集","date":"2017-08-08T06:02:44.000Z","updated":"2017-08-08T06:02:44.000Z","comments":false,"path":"collection/index.html","permalink":"http://www.qirenji.info/collection/index.html","excerpt":"","text":"Nginx能用来做什么 张鑫旭blog 阮一峰blog w3school 菜鸟教程 css88 jQuery中文文档 Bootstrap中文文档 ES6语法 Webpack2.x文档 Vue文档 NodeJs API文档 Express文档"},{"title":"","date":"2017-07-18T06:39:44.000Z","updated":"2017-07-18T06:39:44.000Z","comments":false,"path":"tags/index.html","permalink":"http://www.qirenji.info/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"数组去重的方法","slug":"数组去重的方法","date":"2017-08-25T07:03:25.000Z","updated":"2017-08-25T07:07:11.000Z","comments":true,"path":"2017/08/25/数组去重的方法/","link":"","permalink":"http://www.qirenji.info/2017/08/25/数组去重的方法/","excerpt":"","text":"网上常见的几种方法常规比较法思路：定义一个新数组，并存放原数组的第一个元素，然后将元素组一一和新数组的元素对比，若不同则存放在新数组中。 12345678910111213141516function unique(arr)&#123; var res = [arr[0]]; for(var i=1;i&lt;arr.length;i++)&#123; var repeat = false; for(var j=0;j&lt;res.length;j++)&#123; if(arr[i] == res[j])&#123; repeat = true; break; &#125; &#125; if(!repeat)&#123; res.push(arr[i]); &#125; &#125; return res;&#125; 先排序在去重思路：先将原数组排序，在与相邻的进行比较，如果不同则存入新数组12345678910function unique2(arr)&#123; arr.sort(); var newArr = [arr[0]]; for(var i=1, len=arr.length; i&lt;len; i++)&#123; if(arr[i] !== newArr[newArr.length-1])&#123; newArr.push(arr[i]); &#125; &#125; return newArr;&#125; 数组下标去重123456789function unique1(arr)&#123; var newArr = [];//新建一个数组 for(var i=0,len=arr.length;i&lt;len;i++)&#123; if(newArr.indexOf(arr[i]) == -1)&#123;//若新数组中未包含该项则将其存入新数组 newArr.push(arr[i]); &#125; &#125; return newArr;&#125; 利用对象的属性去重思路：每次取出原数组的元素，然后再对象中访问这个属性，如果存在就说明重复1234567891011function unique(arr)&#123; var res =[]; var json = &#123;&#125;; for(var i=0;i&lt;arr.length;i++)&#123; if(!json[arr[i]])&#123; res.push(arr[i]); json[arr[i]] = 1; &#125; &#125; return res;&#125; 说明利用对象的属性去重比较常用，兼容性也比较好。 ES6新方法ES6新增了Set对象，也就是我们所说的“集合”，它类似于数组，但是成员的值都是唯一的，没有重复的值。所以可以方便去重。 如果用ES6为 Array 对象添加一个去除重复项的方法，则可以如下实现： 123Array.prototype.uniq = function() &#123; return [...new Set(this)];&#125; 去重关键代码只需要一行，是不是非常简单？😄","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.qirenji.info/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.qirenji.info/tags/JavaScript/"},{"name":"ES6","slug":"ES6","permalink":"http://www.qirenji.info/tags/ES6/"}]},{"title":"Node.js + mongoDB + glup 搭建的电影网站","slug":"Node-js-mongoDB-glup-搭建的电影网站","date":"2017-08-12T07:43:27.000Z","updated":"2017-08-28T07:48:20.000Z","comments":true,"path":"2017/08/12/Node-js-mongoDB-glup-搭建的电影网站/","link":"","permalink":"http://www.qirenji.info/2017/08/12/Node-js-mongoDB-glup-搭建的电影网站/","excerpt":"","text":"Node.js + mongoDB + glup 搭建的电影网站前言此项目是基于 Node.js + Express + mongoDB + Bootstrap + gulp 搭建的电影网站。 github地址：https://github.com/qirenji/movie 实现功能 [x] 前台电影展示页 [x] 电影详情页 [x] 后台电影管理中心（电影录入、电影修改） [x] 用户登录注册注销功能 [x] 后台用户管理中心（用户录入、用户修改） [x] 电影评论 [x] 电影分类管理（分类录入、修改）预览在线预览地址 👉 http://60.205.181.124:18002/ 电影首页 电影首页 登录页 登录页 电影录入页 电影录入页 电影列表页 电影列表页 电影分类页 电影分类页 技术栈【前端】 HTML/CSS/JS：亘古不变三件套 ES6：ECMAScript 新一代语法，这也是以后的趋势 Monment.js：时间日期格式化插件 jQuery：主要用到 jQuery 的 ajax 方法处理异步请求和 DOM 操作 Bootstrap：页面 UI 框架，天然响应式 用SCSS做CSS预处理语言。 【后端】 pug：pug (以前的 jade) 是一个高性能的模板引擎，用来生成 HTML Node.js：整个后端由 Node.js 驱动；用 npm 安装资源文件 Express：一个基于 Node.js 平台的 web 开发框架，由路由和中间件构成 【数据库】 mongoDB：进行数据存储的 NoSQL 数据库 【自动化构建】 gulp：前端自动化构建工具 【部署工具】 pm2: Node 应用的进程管理器。 目录结构1234567891011121314151617|-- movie-node // 项目根目录| |-- app // 后台相关目录| |-- controllers // 控制层| |-- models // 数据模型| |-- schemas // 模型结构| |-- views // 视图层| |-- config // 路由管理| |-- movie-backup // 数据库备份| |-- public // 公用资源| |-- dist // 公共资源打包目录| |-- images // 公用图片| |-- sass // 公用样式（初始化等）| |-- scripts // 脚本交互文件| |-- App.js // 程序入口文件| |-- ecosystem.json // pm2配置文件| |-- gulpfile.js // gulp配置文件| |-- package.json // 项目配置信息 总结 熟悉了 pug 的语法及其在 Node.js 中的使用方法 初步掌握了 express 框架的使用，如何处理路由以及中间件 掌握了 mongoose 在 Node.js 中如何连接数据库，以及 schema、model 的使用 前后端数据传递与视图展现的流程 学会了使用 bcryptjs（Node.js 的一个加解密模块）对密码进行 “hash + salt” 处理 借助会话与 cookie 进行用户识别和持久化 About关于我: http://www.qirenji.info/about GitHub: https://github.com/qirenji/ E-mail: lyf@qirenji.com","categories":[{"name":"Node","slug":"Node","permalink":"http://www.qirenji.info/categories/Node/"},{"name":"实战项目","slug":"Node/实战项目","permalink":"http://www.qirenji.info/categories/Node/实战项目/"}],"tags":[{"name":"Node","slug":"Node","permalink":"http://www.qirenji.info/tags/Node/"},{"name":"mongodb","slug":"mongodb","permalink":"http://www.qirenji.info/tags/mongodb/"},{"name":"电影网站","slug":"电影网站","permalink":"http://www.qirenji.info/tags/电影网站/"}]},{"title":"Vue.js打造的音乐播放器","slug":"Vue-js打造的音乐播放器","date":"2017-08-10T04:17:34.000Z","updated":"2017-08-28T04:28:16.000Z","comments":true,"path":"2017/08/10/Vue-js打造的音乐播放器/","link":"","permalink":"http://www.qirenji.info/2017/08/10/Vue-js打造的音乐播放器/","excerpt":"","text":"Vue.js打造的音乐播放器前言vue学习项目，基于qq音乐API，完成音乐播放和搜索等。 Github地址：https://github.com/qirenji/music-vue 实现功能 [x] 音乐播放 [x] 音乐控制和自动循环播放 [x] 音乐搜索 [x] 播放详情页 [x] 音乐进度拖拽 [x] 个人中心模版 预览在线预览地址 👉 http://60.205.181.124:18003/ 技术栈 Vue2.0：前端页面展示。 Vue-cli：vue手脚架工具。 vue-router：页面路由切换。 axios：向后端发起请求。 Vuex：实现不同组件间的状态共享。 ES6：箭头函数等语法很好用。 localStorage：本地存储，保存歌单和个性化设置。 Express：后端调用qq音乐API，返回数据。 Webpack：vue-cli自带Webpack，添加sass相关loader，其他vue-cli已经配置好了webpack，你只需要安装依赖就可以，使用的时候只需要。 SASS(SCSS)：用SCSS做CSS预处理语言。 flex：flex弹性布局，简单适配手机、PC端。 CSS3：CSS3过渡动画及样式。 目录结构项目使用vue-cli手脚架工具搭建，大部分源文件放在src目录下，所有这里只列出src目录结构，其他请参考vue-cli手脚架工具1234567891011121314|-- src // 源码目录| |-- components // 公共组件| |-- about // 关于页| |-- find // 搜索页| |-- footer // mini播放器| |-- header // 页面头部| |-- musiclist // 歌曲列表页| |-- play // 播放详情页| |-- social // 个人中心页| |-- common // 公用资源| |-- style // 公用sass样式（默认样式）| |-- router // 配置页面路由| |-- App.vue // 页面入口文件| |-- main.js // 程序入口文件，加载各种公共组件 总结 深入学习vue.js全家桶，使用Vuex管理组件状态很方便。 事先要先想好整个页面结构和组件划分，方便快速开发。 About关于我: http://www.qirenji.info/about GitHub: https://github.com/qirenji/ E-mail: lyf@qirenji.com","categories":[{"name":"Vue","slug":"Vue","permalink":"http://www.qirenji.info/categories/Vue/"},{"name":"实战项目","slug":"Vue/实战项目","permalink":"http://www.qirenji.info/categories/Vue/实战项目/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://www.qirenji.info/tags/Vue/"},{"name":"Vue音乐播放器","slug":"Vue音乐播放器","permalink":"http://www.qirenji.info/tags/Vue音乐播放器/"}]},{"title":"城市选择器插件（三级联动）","slug":"城市选择器插件（三级联动）","date":"2017-08-08T14:49:20.000Z","updated":"2017-08-28T08:58:31.000Z","comments":true,"path":"2017/08/08/城市选择器插件（三级联动）/","link":"","permalink":"http://www.qirenji.info/2017/08/08/城市选择器插件（三级联动）/","excerpt":"","text":"城市选择器(三级联动)介绍一个中国地区的三级联动数据，也可以自定义数据。 github地址: https://github.com/qirenji/select-plugin 使用默认数据引入js文件。 在html文件中插入 123456789// html中添加&lt;div class=\"container\"&gt;&lt;/div&gt;&lt;script src=\"dist/all.js\"&gt;&lt;/script&gt;&lt;script&gt; let selector = new Select('.container',default_data);&lt;/script&gt; 默认就可以生成中国地区的三级联动数据啦 自定义数据12345678910111213141516171819202122//html中添加&lt;div class=\"container1\"&gt;&lt;/div&gt;&lt;script src=\"dist/all.js\"&gt;&lt;/script&gt;&lt;script&gt; const text = ['选项1','选项二','选项三'] //自定义数据 const data = &#123; 'province': ['a1', 'a2', 'a3'], 'city': [ ['a11', 'a12', 'a13'], ['a21', 'a22'], ['a31', 'a32'] ], 'county': [ [['a111', 'a112'], ['a121', 'a122'], ['a131', 'a132']], [['a211', 'a212'], ['a221', 'a222']], [['a311'], ['a312']] ] &#125;; let selector1 = new Select('.container1',data, text)&lt;/script&gt; 第一个参数是插件所在的父容器 第二个参数是插件所要选择的数据（json形式） 第三个参数是选择器前面的提示词语 效果图 城市选择器插件 自定义数据选择 About关于我: http://www.qirenji.info/about GitHub: https://github.com/qirenji/ E-mail: lyf@qirenji.com","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.qirenji.info/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.qirenji.info/tags/JavaScript/"},{"name":"组件","slug":"组件","permalink":"http://www.qirenji.info/tags/组件/"}]},{"title":"gulp执行顺序(gulp-sequence)","slug":"gulp执行顺序-gulp-sequence","date":"2017-08-02T02:40:23.000Z","updated":"2017-08-25T02:43:04.000Z","comments":true,"path":"2017/08/02/gulp执行顺序-gulp-sequence/","link":"","permalink":"http://www.qirenji.info/2017/08/02/gulp执行顺序-gulp-sequence/","excerpt":"","text":"介绍Node.js 工具链中的典型任务运行器有 Grunt ，以及后起之秀 Gulp。 与以传统的方式进行配置的 Grunt 相比， Gulp 则使用“代码”的方式来描述任务。而它们另一个巨大的不同，则体现在运行方式上：Grunt 的运行方式很直观：解析依赖，使用配置逐步运行已定义的任务；而 Gulp 则默认将所有任务和步骤异步化运行。显而易见，Gulp 在效率上是有明显的提升的。 问题上文介绍gulp是异步的，但是当写完一系列任务准备执行时 1gulp.task('build', ['clean', 'styles', 'images', 'scripts'])); 发现终端报错 image 如上图所示，任务完全错乱了，我们是想先执行clean，然后执行scritp和styles等任务。但由于异步操作，导致了执行出错。 当然如果是一个任务，可以使用依赖 1gulp.task('scripts', ['clean'])); 这样就可以在执行clean后执行scripts任务了。 但我们有一系列任务，这时候就可以使用国内的 Teambition 团队开源了 gulp-sequence ，以及国外开发者开发的 run-sequence来完美解决这个问题。 gulp-sequence它们提供了类似的调用方式，下面的代码演示如何使用 gulp-sequence 按顺序地运行多个或多组 Gulp 任务： 123var gulpSequence = require('gulp-sequence'); gulp.task('build', gulpSequence('clean', ['styles', 'images', 'scripts'])); 这样就可以预期的先执行clean再之行其他任务了。 具体终端执行结果如下图 image","categories":[{"name":"工具","slug":"工具","permalink":"http://www.qirenji.info/categories/工具/"},{"name":"gulp","slug":"工具/gulp","permalink":"http://www.qirenji.info/categories/工具/gulp/"}],"tags":[{"name":"gulp","slug":"gulp","permalink":"http://www.qirenji.info/tags/gulp/"},{"name":"自动化工具","slug":"自动化工具","permalink":"http://www.qirenji.info/tags/自动化工具/"}]},{"title":"Vue.js开源的CNode社区","slug":"Vue-js开源的CNode社区","date":"2017-08-01T02:08:02.000Z","updated":"2017-08-28T02:12:18.000Z","comments":true,"path":"2017/08/01/Vue-js开源的CNode社区/","link":"","permalink":"http://www.qirenji.info/2017/08/01/Vue-js开源的CNode社区/","excerpt":"","text":"Vue.js开源的CNode社区前言vue练习项目，利用cnode社区提供的api实现，需去cnode个人中心登陆查看accesstoken才可以登录。Github地址：https://github.com/qirenji/cnode-vue 实现功能 [x] 首页列表，下拉加载 – 完成 [x] 主题详情，回复，点赞 – 完成 [x] 登录,退出 –完成 [x] 消息列表，消息提醒，消息标记为已读 – 完成 [x] 发布话题 – 完成 [x] 个人中心 – 完成 预览在线预览地址 👉 http://60.205.181.124:18000/ 首页 首页 文章详情页 文章详情页 侧边栏 侧边栏 回复页面 回复页面 发布话题页 发布话题页 技术栈 Vue2.0：前端页面展示。 Vue-cli：vue手脚架工具。 Vuex：实现不同组件间的状态共享。 vue-router：页面路由切换。 axios：向后端发起请求。 Socket.io：实现实时通信 Moment.js：格式化时间。 ES6：箭头函数等语法很好用。 localStorage：保存用户信息。 Webpack：vue-cli自带Webpack，添加sass相关loader，其他vue-cli已经配置好了webpack，你只需要安装依赖就可以，使用的时候只需要。 SASS(SCSS)：用SCSS做CSS预处理语言。 flex：flex弹性布局，简单适配手机、PC端。 CSS3：CSS3过渡动画及样式。 目录结构项目使用vue-cli手脚架工具搭建，大部分源文件放在src目录下，所有这里只列出src目录结构，其他请参考vue-cli手脚架工具1234567891011121314151617|-- src // 源码目录| |-- components // 公共组件| |-- about // 关于页| |-- asidemenu // 侧边栏页| |-- content // 文章列表页和文章详情页 | |-- header // 首页头部| |-- info // 个人中心页| |-- login // 登陆页| |-- newarticle // 新建话题页| |-- user // 用户详情页| |-- common // 公用资源| |-- style // 公用sass样式（默认样式）| |-- icons // 公用svg图标页| |-- js // 公用javascript| |-- router // 配置页面路由| |-- App.vue // 页面入口文件| |-- main.js // 程序入口文件，加载各种公共组件 总结 深入学习vue.js全家桶，使用Vuex管理组件状态很方便。 事先要先想好整个页面结构和组件划分，方便快速开发。 About关于我: http://www.qirenji.info/about GitHub: https://github.com/qirenji/ E-mail: lyf@qirenji.com","categories":[{"name":"Vue","slug":"Vue","permalink":"http://www.qirenji.info/categories/Vue/"},{"name":"实战项目","slug":"Vue/实战项目","permalink":"http://www.qirenji.info/categories/Vue/实战项目/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://www.qirenji.info/tags/Vue/"},{"name":"CNode社区","slug":"CNode社区","permalink":"http://www.qirenji.info/tags/CNode社区/"}]},{"title":"gulp学习","slug":"gulp学习","date":"2017-07-31T15:31:43.000Z","updated":"2017-08-09T02:38:31.000Z","comments":true,"path":"2017/07/31/gulp学习/","link":"","permalink":"http://www.qirenji.info/2017/07/31/gulp学习/","excerpt":"","text":"glup学习gulpjs是一个前端构建工具，与gruntjs相比，gulpjs无需写一大堆繁杂的配置参数，API也非常简单，学习起来很容易，而且gulpjs使用的是nodejs中stream来读取和操作数据，其速度更快。 安装在项目根目录执行 1234 //全局安装npm install -g gulp //项目使用npm install --save-dev gulp 创建gulpfile.js就像gruntjs需要一个Gruntfile.js文件一样，gulp也需要一个文件作为它的主文件，在gulp中这个文件叫做gulpfile.js 123456此时我们的目录结构是这样子的：├── gulpfile.js├── node_modules│ └── gulp└── package.json 添加的gulpfile.js内容大概是这样的。 1234567891011121314151617//导入工具包 require('node_modules里对应模块')var gulp = require('gulp'), //本地安装gulp所用到的地方 less = require('gulp-less'); //定义一个testLess任务（自定义任务名称）gulp.task('testLess', function () &#123; gulp.src('src/less/index.less') //该任务针对的文件 .pipe(less()) //该任务调用的模块 .pipe(gulp.dest('src/css')); //将会在src/css下生成index.css&#125;); gulp.task('default',['testLess', 'elseTask']); //定义默认任务 elseTask为其他任务，该示例没有定义elseTask任务 //gulp.task(name[, deps], fn) 定义任务 name：任务名称 deps：依赖任务名称 fn：回调函数//gulp.src(globs[, options]) 执行任务处理的文件 globs：处理的文件路径(字符串或者字符串数组) //gulp.dest(path[, options]) 处理完后文件生成路径//gulp.watch(glob [, opts], tasks) 监视文件，并且可以在文件发生改动时候做一些事情。 运行glup 1gulp task1 常用插件自动加载插件gulp-load-plugins这个插件能自动帮你加载package.json文件里的gulp插件。 123var gulp = require('gulp');//加载gulp-load-plugins插件，并马上运行它var plugins = require('gulp-load-plugins')(); 注意必须要保证你需要自动加载的插件已经写入到了package.json文件里 重命名gulp-rename 用来重命名文件流中的文件。 12345678910var gulp = require('gulp'), rename = require('gulp-rename'), uglify = require(\"gulp-uglify\"); gulp.task('rename', function () &#123; gulp.src('js/jquery.js') .pipe(uglify()) //压缩 .pipe(rename('jquery.min.js')) //会将jquery.js重命名为jquery.min.js .pipe(gulp.dest('js'));&#125;); ES6文件转换gulp-babel 用来转换ES6或ES7 需要安装babel-preset-es2015插件，才能把es6编译成es512345678910var gulp = require(\"gulp\");var babel = require(\"gulp-babel\");gulp.task(\"default\", function () &#123; return gulp.src(\"src/app.js\") .pipe(babel(&#123; presets: ['es2015'] &#125;)) .pipe(gulp.dest(\"dist\"));&#125;); js文件压缩gulp-uglify 用来压缩js文件，使用的是uglify引擎 12345678var gulp = require('gulp'), uglify = require(\"gulp-uglify\"); gulp.task('minify-js', function () &#123; gulp.src('js/*.js') // 要压缩的js文件 .pipe(uglify()) //使用uglify进行压缩,更多配置请参考： .pipe(gulp.dest('dist/js')); //压缩后的路径&#125;); css文件压缩gulp-minify-css 要压缩css文件时可以使用该插件 12345678var gulp = require('gulp'), minifyCss = require(\"gulp-minify-css\"); gulp.task('minify-css', function () &#123; gulp.src('css/*.css') // 要压缩的css文件 .pipe(minifyCss()) //压缩css .pipe(gulp.dest('dist/css'));&#125;); html文件压缩gulp-minify-html 12345678var gulp = require('gulp'), minifyHtml = require(\"gulp-minify-html\"); gulp.task('minify-html', function () &#123; gulp.src('html/*.html') // 要压缩的html文件 .pipe(minifyHtml()) //压缩 .pipe(gulp.dest('dist/html'));&#125;); js代码检查gulp-jshint 12345678var gulp = require('gulp'), jshint = require(\"gulp-jshint\"); gulp.task('jsLint', function () &#123; gulp.src('js/*.js') .pipe(jshint()) .pipe(jshint.reporter()); // 输出检查结果&#125;); 文件合并gulp-concat 12345678var gulp = require('gulp'), concat = require(\"gulp-concat\"); gulp.task('concat', function () &#123; gulp.src('js/*.js') //要合并的文件 .pipe(concat('all.js')) // 合并匹配到的js文件并命名为 \"all.js\" .pipe(gulp.dest('dist/js'));&#125;); less和sass的编译less使用gulp-less 12345678var gulp = require('gulp'), less = require(\"gulp-less\"); gulp.task('compile-less', function () &#123; gulp.src('less/*.less') .pipe(less()) .pipe(gulp.dest('dist/css'));&#125;); sass使用gulp-sass 12345678var gulp = require('gulp'), sass = require(\"gulp-sass\"); gulp.task('compile-sass', function () &#123; gulp.src('sass/*.sass') .pipe(sass()) .pipe(gulp.dest('dist/css'));&#125;); 图片压缩gulp-imagemin插件来压缩jpg、png、gif等图片 123456789101112var gulp = require('gulp');var imagemin = require('gulp-imagemin');var pngquant = require('imagemin-pngquant'); //png图片压缩插件gulp.task('default', function () &#123; gulp.src('src/images/*') .pipe(imagemin(&#123; progressive: true, use: [pngquant()] //使用pngquant来压缩png图片 &#125;)) .pipe(gulp.dest('dist'));&#125;); gulp-imagemin的使用比较复杂一点，而且它本身也有很多插件，建议去它的项目主页看看文档。 自动化gulp-livereload该插件最好配合谷歌浏览器来使用，且要安装livereload chrome extension扩展插件 123456789101112131415var gulp = require('gulp'), less = require('gulp-less'), livereload = require('gulp-livereload');gulp.task('less', function() &#123; gulp.src('less/*.less') .pipe(less()) .pipe(gulp.dest('css')) .pipe(livereload());&#125;);gulp.task('watch', function() &#123; livereload.listen(); //要在这里调用listen()方法 gulp.watch('less/*.less', ['less']);&#125;); browser-sync12345678910111213141516171819var gulp = require('gulp');var browserSync = require('browser-sync').create(); gulp.task('js-watch', ['js'], browserSync.reload);// 使用默认任务启动Browsersync，监听JS文件gulp.task('default', ['js'], function () &#123; // 从这个项目的根目录启动服务器 browserSync.init(&#123; server: &#123; baseDir: \"./\" &#125; &#125;); // 添加 browserSync.reload 到任务队列里 // 所有的浏览器重载后任务完成。 gulp.watch(\"js/*.js\", ['js-watch']);&#125;); 实例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778var gulp = require('gulp');var browsersync = require('browser-sync').create();//删除dist目录下文件var del=require('del');gulp.task('clean',function(cb)&#123; return del(['dist/*'],cb);&#125;)//操作js文件var uglify = require('gulp-uglify');var concat = require('gulp-concat');var babel = require('gulp-babel');var babeles2015 = require('babel-preset-es2015');gulp.task('js',function()&#123; gulp.src('src/js/*.js') .pipe(babel(&#123; presets: ['es2015'] &#125;)) .pipe(concat('all.js')) .pipe(uglify()) .pipe(gulp.dest('dist/js')) .pipe(browsersync.stream()); //文件有更新自动执行&#125;)//操作css文件var cssnano = require('gulp-cssnano');//css压缩插件// var less=require('gulp-less');//less文件编译gulp.task('css', function() &#123; gulp.src('src/css/*.css') // .pipe(less()) //编译less文件 .pipe(cssnano())//css压缩 .pipe(gulp.dest('dist/css')) .pipe(browsersync.stream());&#125;);var htmlmin = require('gulp-htmlmin'); //html压缩插件gulp.task('html', function() &#123; gulp.src('src/*.html') .pipe(htmlmin(&#123; //压缩html collapseWhitespace: true, //省略布尔属性的值 collapseBooleanAttributes: true, //清除html注释 removeComments: true, //删除所有空格作为属性值 removeEmptyAttributes: true, //删除type=text/javascript removeScriptTypeAttributes: true, //删除type=text/css removeStyleLinkTypeAttributes: true, //压缩页面js minifyJS:true, //压缩页面css minifyCSS:true &#125;)) .pipe(gulp.dest('dist')) .pipe(browsersync.stream());&#125;);gulp.task('serve', ['clean'], function() &#123; gulp.start('js','css','html'); browsersync.init(&#123; port: 3000, server: &#123; baseDir: ['dist'] &#125; &#125;); gulp.watch('src/js/*.js', ['js']); //监控文件变化，自动更新 gulp.watch('src/css/*.css', ['css']); gulp.watch('src/*.html', ['html']);&#125;);gulp.task('default',['serve']); gulp学习资料 Gulp：任务自动管理工具 gulp plugins 插件介绍 https://github.com/gulpjs/gulp Browsersync / 说明文档","categories":[{"name":"工具","slug":"工具","permalink":"http://www.qirenji.info/categories/工具/"},{"name":"gulp","slug":"工具/gulp","permalink":"http://www.qirenji.info/categories/工具/gulp/"}],"tags":[{"name":"gulp","slug":"gulp","permalink":"http://www.qirenji.info/tags/gulp/"},{"name":"自动化工具","slug":"自动化工具","permalink":"http://www.qirenji.info/tags/自动化工具/"}]},{"title":"webpack学习","slug":"webpack学习","date":"2017-07-29T15:50:25.000Z","updated":"2017-07-30T15:52:32.000Z","comments":true,"path":"2017/07/29/webpack学习/","link":"","permalink":"http://www.qirenji.info/2017/07/29/webpack学习/","excerpt":"","text":"webpack学习webpack室一款模块加载器兼打包工具，它能把各种资源，例如JS、样式（含less/sass）、图片等都作为模块来使用和处理。 webpack不同于gulp和grunt。 gulp是工具链、构建工具，可以配合各种插件做js压缩，css压缩，less编译 替代手工实现自动化的工具 1.构建工具 2.自动化 3.提高效率用 webpack是文件打包工具，可以把项目的各种js文、css文件等打包合并成一个或多个文件，主要用于模块化方案，预编译模块的方案。 1.打包工具 2.模块化识别 3.编译模块代码方案用 webpack的官网是 http://webpack.github.io/ ，文档地址是 http://webpack.github.io/docs/ 。 webpack主要有4大核心概念 Entryentry 是页面入口文件配置，其语法大致为： 123456&#123; entry: &#123; page1: \"./page1\", page2: [\"./entry1\", \"./entry2\"] &#125;&#125; outputoutput 是对应输出项配置（即入口文件最终要生成什么名字的文件、存放到哪里） 1234output: &#123; path: \"dist/js/page\", filename: \"[name].bundle.js\" &#125; module.loaders module.loaders 是最关键的一块配置。它告知 webpack 每一种文件都需要使用什么加载器来处理： 12345678910111213module: &#123; //加载器配置 loaders: [ //.css 文件使用 style-loader 和 css-loader 来处理 &#123; test: /\\.css$/, loader: 'style-loader!css-loader' &#125;, //.js 文件使用 jsx-loader 来编译处理 &#123; test: /\\.js$/, loader: 'jsx-loader?harmony' &#125;, //.scss 文件使用 style-loader、css-loader 和 sass-loader 来编译处理 &#123; test: /\\.scss$/, loader: 'style!css!sass?sourceMap'&#125;, //图片文件使用 url-loader 来处理，小于8kb的直接转为base64 &#123; test: /\\.(png|jpg)$/, loader: 'url-loader?limit=8192'&#125; ] &#125; PluginsLoaders是以单个文件为基础对文件进行操作，而Plugins与Loaders不同的是，Plugins是对整体进行操作。 使用插件，你只需要将其进行引入到配置文件并添加到plugins数组中，大多数的插件都是可通过选项进行配置。 1234plugins: [ new webpack.optimize.UglifyJsPlugin(), //丑化压缩JS new HtmlWebpackPlugin(&#123;template: './src/index.html'&#125;) //生成HTML模板 ] 如需了解更多，请跳转址webpack中文教程。","categories":[{"name":"webpack","slug":"webpack","permalink":"http://www.qirenji.info/categories/webpack/"},{"name":"工具","slug":"webpack/工具","permalink":"http://www.qirenji.info/categories/webpack/工具/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"http://www.qirenji.info/tags/webpack/"},{"name":"打包工具","slug":"打包工具","permalink":"http://www.qirenji.info/tags/打包工具/"}]},{"title":"Vue.js+Socket.io- 智能聊天室","slug":"Vue-js-Socket-io-智能聊天室","date":"2017-07-27T13:02:29.000Z","updated":"2017-08-28T02:11:21.000Z","comments":true,"path":"2017/07/27/Vue-js-Socket-io-智能聊天室/","link":"","permalink":"http://www.qirenji.info/2017/07/27/Vue-js-Socket-io-智能聊天室/","excerpt":"","text":"Vue.js+Socket.io- 智能聊天室前言本项目是使用Vue.js+Socket.io+Express实现的一个多人聊天室，也可以和智能机器人聊天，这里调用青云客API接口。本项目虽然简单，但对vue的技术使用的还是比较全面的。 源码地址 👉 https://github.com/qirenji/chat-vue 实现功能 [x] 登录功能 – 完成 [x] 聊天功能 – 完成 [x] 多人聊天室 – 完成 [x] 与机器人聊天 – 完成 预览在线预览地址 👉 http://60.205.181.124:18004/ 多人群聊效果预览 多人群聊效果图 智能机器人聊天效果预览 智能机器人聊天效果图 技术栈 Vue2.0：前端页面展示。 Socket.io：实现实时通信 Vuex：实现不同组件间的状态共享 vue-router：页面路由切换 axios：向后端发起请求。 Express：实现后端socket.io监听功能。 Moment.js：格式化时间。 ES6：箭头函数等语法很好用。 localStorage：保存用户信息以及聊天记录。 Webpack：vue-cli自带Webpack，添加sass相关loader，其他vue-cli已经配置好了webpack，你只需要安装依赖就可以，使用的时候只需要。 SASS(SCSS)：用SCSS做CSS预处理语言。 flex：flex弹性布局，简单适配手机、PC端。 CSS3：CSS3过渡动画及样式。 分析socket.io 在服务器端 12345678io.on('connection', (socket) =&gt; &#123; // 群聊 socket.on('sendGroupMsg', function (data) &#123; socket.broadcast.emit('receiveGroupMsg', data); &#125;);&#125;) 在客户端 123456789101112131415&lt;script src=\"/socket.io/socket.io.js\"&gt;&lt;/script&gt;&lt;script&gt; //上线发送名称信息 socket.emit('online', this.$store.state.name); // console.log(this.$store.state.name); // 监听是否有上线的 socket.on('online', (name) =&gt; &#123; …… &#125;); // 监听是否有人在发送信息 socket.on('receiveGroupMsg', data =&gt; &#123; …… &#125;);&lt;/script&gt; 总结不管是服务器还是客户端都有 emit 和 on 这两个函数，可以说 socket.io 的核心就是这两个函数了，通过 emit 和 on 可以轻松地实现服务器与客户端之间的双向通信。 ##emit## ：用来触发一个事件，第一个参数为事件名，第二个参数为要发送的数据,如果要向所有在线的人发送信息需要夹，broadcast是发送信息到广播组的其他人。 ##on## ：用来监听一个 emit 触发的事件，第一个参数为要监听的事件名，第二个参数为一个匿名函数用来接收对方发来的数据。 About关于我: http://www.qirenji.info GitHub: https://github.com/qirenji/ E-mail: lyf@qirenji.com","categories":[{"name":"Vue","slug":"Vue","permalink":"http://www.qirenji.info/categories/Vue/"},{"name":"实战项目","slug":"Vue/实战项目","permalink":"http://www.qirenji.info/categories/Vue/实战项目/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://www.qirenji.info/tags/Vue/"},{"name":"智能聊天室","slug":"智能聊天室","permalink":"http://www.qirenji.info/tags/智能聊天室/"}]},{"title":"nginx学习","slug":"nginx学习","date":"2017-07-26T14:04:29.000Z","updated":"2017-07-26T14:05:42.000Z","comments":true,"path":"2017/07/26/nginx学习/","link":"","permalink":"http://www.qirenji.info/2017/07/26/nginx学习/","excerpt":"","text":"ngix学习静态HTTP服务器首先，Nginx是一个HTTP服务器，可以将服务器上的静态文件（如HTML、图片）通过HTTP协议展现给客户端。 123456server &#123; listen 80; # 端口号 location / &#123; root /usr/share/nginx/html; # 静态文件路径 &#125;&#125; 反向代理服务器客户端本来可以直接通过HTTP协议访问某网站应用服务器，如果网站管理员在中间加上一个Nginx，客户端请求Nginx，Nginx请求应用服务器，然后将结果返回给客户端，此时Nginx就是反向代理服务器。 12345listen 80; location / &#123; proxy_pass http://192.168.20.1:8080; # 应用服务器HTTP地址 &#125;&#125; 负载均衡当网站访问量非常大，网站站长开心赚钱的同时，也摊上事儿了。因为网站越来越慢，一台服务器已经不够用了。于是将相同的应用部署在多台服务器上，将大量用户的请求分配给多台机器处理。同时带来的好处是，其中一台服务器万一挂了，只要还有其他服务器正常运行，就不会影响用户使用。 Nginx可以通过反向代理来实现负载均衡。 12345678910upstream myapp &#123; server 192.168.20.1:8080; # 应用服务器1 server 192.168.20.2:8080; # 应用服务器2&#125;server &#123; listen 80; location / &#123; proxy_pass http://myapp; &#125;&#125; 虚拟主机网站访问量大，需要负载均衡。然而并不是所有网站都如此出色，有的网站，由于访问量太小，需要节省成本，将多个网站部署在同一台服务器上。例如将www.aaa.com和www.bbb.com两个网站部署在同一台服务器上，两个域名解析到同一个IP地址，但是用户通过两个域名却可以打开两个完全不同的网站，互相不影响，就像访问两个服务器一样，所以叫两个虚拟主机。 12345678910111213141516171819server &#123; listen 80 default_server; server_name _; return 444; # 过滤其他域名的请求，返回444状态码&#125;server &#123; listen 80; server_name www.aaa.com; # www.aaa.com域名 location / &#123; proxy_pass http://localhost:8080; # 对应端口号8080 &#125;&#125;server &#123; listen 80; server_name www.bbb.com; # www.bbb.com域名 location / &#123; proxy_pass http://localhost:8081; # 对应端口号8081 &#125;&#125; 在服务器8080和8081分别开了一个应用，客户端通过不同的域名访问，根据server_name可以反向代理到对应的应用服务器。","categories":[{"name":"服务器","slug":"服务器","permalink":"http://www.qirenji.info/categories/服务器/"},{"name":"Nginx","slug":"服务器/Nginx","permalink":"http://www.qirenji.info/categories/服务器/Nginx/"}],"tags":[{"name":"Nginx","slug":"Nginx","permalink":"http://www.qirenji.info/tags/Nginx/"}]},{"title":"git提交到多个远程仓库","slug":"git提交到多个远程仓库","date":"2017-07-25T03:11:05.000Z","updated":"2017-08-25T03:12:13.000Z","comments":true,"path":"2017/07/25/git提交到多个远程仓库/","link":"","permalink":"http://www.qirenji.info/2017/07/25/git提交到多个远程仓库/","excerpt":"","text":"问题分别有仓库A（github）,B（码云的git），本机为C。 假设以 a 仓库作为最终的使用仓库， b为发布仓库，想两个仓库一起使用，怎么用呢？ 增加远程仓库1234#添加githubgit remote add origin https://github.com/xxx(仓库地址)#添加oschinagit remote set-url --add origin https://git.oschina.net/xxxx(仓库地址) 提交1git push origin --all 这样就可以把本机的代码提交两个仓库了。 但是如果两个仓库都有内容。那么问题来了： 怎么才能把两个远程仓库代码同步？以便以后可以代码同时推送到这两个仓库。 直接在命令行敲： 123git push -f origin --all 注释： origin 远程仓库名， master 分支名， -f 为force，意为：强行、强制。 当然不止这一种操作方式了，但是这种操作是最快速的，不会有冲突什么。 ⚠️：这个-f命令请谨慎使用：请谨慎使用！请谨慎使用！请谨慎使用！ 毕竟数据无价，如果被覆盖后，就不那么好恢复了。","categories":[{"name":"远程管理","slug":"远程管理","permalink":"http://www.qirenji.info/categories/远程管理/"}],"tags":[{"name":"git","slug":"git","permalink":"http://www.qirenji.info/tags/git/"},{"name":"远程管理","slug":"远程管理","permalink":"http://www.qirenji.info/tags/远程管理/"}]},{"title":"flex布局学习","slug":"flex布局学习","date":"2017-07-24T14:54:39.000Z","updated":"2017-07-24T14:55:49.000Z","comments":true,"path":"2017/07/24/flex布局学习/","link":"","permalink":"http://www.qirenji.info/2017/07/24/flex布局学习/","excerpt":"","text":"Flex布局基本概念Flex意为弹性布局，用来为盒模型提供最大的灵活性。设置为Flex布局之后，float、clear和vertical-align属性将失效。 使用Flex布局，首先要设置父容器为 1display: flex; 这样就可以使用 1justify-content: center; 实现水平居中 1align-items: center; 实现垂直居中。 容器的属性以下6个属性设置在容器上。 flex-direction flex-wrap flex-flow justify-content align-items align-contentflex-direction属性flex-direction属性决定主轴的方向（即项目的排列方向）。 123.flex-box&#123; flex-direction: row | row-reverse | column | column-reverse; &#125; row（默认值）：主轴为水平方向，起点在左端。 row-reverse：主轴为水平方向，起点在右端。 column：主轴为垂直方向，起点在上沿。 column-reverse：主轴为垂直方向，起点在下沿。 flex-wrap属性flex-wrap属性定义，如果一条轴线排不下，如何换行。 123.flex-box&#123; flex-wrap: nowrap | wrap | wrap-reverse;&#125; nowrap ：默认，不换行 wrap ：换行，第一行在上方 wrap-reverse：换行，第一行在下方 flex-flow属性flex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。 123.flex-box &#123; flex-flow: &lt;flex-direction&gt; || &lt;flex-wrap&gt;;&#125; justify-content属性justify-content属性定义了项目在主轴上的对齐方式。 123.flex-box &#123; justify-content: flex-start | flex-end | center | space-between | space-around;&#125; 它可能取5个值，具体对齐方式与轴的方向有关。下面假设主轴为从左到右。 flex-start（默认值）：左对齐 flex-end：右对齐 center： 居中 space-between：两端对齐，项目之间的间隔都相等。 space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。 align-items属性123.flex-box &#123; align-items: flex-start | flex-end | center | baseline | stretch;&#125; 它可能取5个值。具体的对齐方式与交叉轴的方向有关，下面假设交叉轴从上到下。 flex-start：交叉轴的起点对齐。 flex-end：交叉轴的终点对齐。 center：交叉轴的中点对齐。 baseline:项目的第一行文字的基线对齐。 stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。align-content属性 123.flex-box &#123; align-content: flex-start | flex-end | center | space-between | space-around | stretch;&#125; flex-start：与交叉轴的起点对齐。 flex-end：与交叉轴的终点对齐。 center：与交叉轴的中点对齐。 space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。 space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。 stretch（默认值）：轴线占满整个交叉轴(如果项目未设置高度或设为auto时，并且align-item连用，否则失效）) 项目中常用属性首先父级使用 1display：flex 1按比例分配 1flex：n 分配固定像素1flex: 0 0 200px。 来分配200像素的空间。 分配方向默认是水平分配，如需垂直分配，则使用 1flex-direction: column 子项水平居中1justify-content: center 子项垂直居中1align-items: center; 如需学习更多有关flex的相关知识，可去菜鸟教程和阮一峰老师的博客。","categories":[{"name":"CSS3","slug":"CSS3","permalink":"http://www.qirenji.info/categories/CSS3/"}],"tags":[{"name":"flex","slug":"flex","permalink":"http://www.qirenji.info/tags/flex/"},{"name":"CSS3","slug":"CSS3","permalink":"http://www.qirenji.info/tags/CSS3/"}]},{"title":"git常用命令","slug":"git常用命令","date":"2017-07-22T13:48:13.000Z","updated":"2017-07-22T13:49:52.000Z","comments":true,"path":"2017/07/22/git常用命令/","link":"","permalink":"http://www.qirenji.info/2017/07/22/git常用命令/","excerpt":"","text":"git常用命令基本命令使用 在当前目录创建Git仓库，会在当前目录创建.git文件夹 1git init 把文件提交到暂存区 1git add ./&lt;path&gt; 提交当前工作空前的修改内容 1git commit -m '注释' 将存储库克隆到本地目录中 1git clone https://github.com/jquery/jquery.git 将本地分支的更新，推送到远程主机。 1git push origin master 从远程获取最新版本并merge到本地 1git pull 相当于git fetch和git merge一起使用 列出详细信息，在每一个名字后面列出其远程url 1git remote -v 在url创建名字为name的仓库12git remote add origin git@git.*/website_node.git 分支管理 创建分支 1git branch dev 切换分支 1git checkout dev 查看当前分支 1git branch 创建并切换分支 1git branch -d dev 解决冲突Git最常用的可能就是多人协作时解决冲突问题。 一般会先push上自己的文件 123git add .git commit -m '注释'git push -u origin branch-name 然后发现推送失败了，这是因为远程的分支和自己的本地推送内容更新，所以需要使用git pull把远程分支与本地合并。 1git pull 如果合并有冲突，则需要在本地解决冲突。 解决冲突之后，再重新git push就能推送成功了。 1git push origin baranch-name 这就是多人协作之解决冲突。 这里也推荐初学者使用 github desktop，毕竟图形化界面使用起来更直观一些。 如需学习更多内容，请参廖雪峰老师的Git教程","categories":[{"name":"远程管理","slug":"远程管理","permalink":"http://www.qirenji.info/categories/远程管理/"}],"tags":[{"name":"git","slug":"git","permalink":"http://www.qirenji.info/tags/git/"},{"name":"远程管理","slug":"远程管理","permalink":"http://www.qirenji.info/tags/远程管理/"}]},{"title":"vue全家桶总结","slug":"vue全家桶总结","date":"2017-07-20T14:09:27.000Z","updated":"2017-07-20T14:15:18.000Z","comments":true,"path":"2017/07/20/vue全家桶总结/","link":"","permalink":"http://www.qirenji.info/2017/07/20/vue全家桶总结/","excerpt":"","text":"vue全家桶学习一. vue-cli(手脚架搭建项目)初始化项目1vue init webpack projectName 然后顺序执行如下命令，可启动vue项目 123cd my-projectnpm installnpm run dev 如项目中使用其他库或组件需 1npm install *** --save-dev 例如使用scss编写软件,需安装sass编译工具 1npm install sass sass-loader node-sass --save-dev 二.vue-routervue-router主要作为程序的路由控制器 使用： main.js中添加router 1234567import router from ‘./router’new Vue(&#123; el: '#app', router, template: '&lt;App/&gt;', components: &#123; App &#125;&#125;) ./router/index.js文件中 12345678910111213141516import Router from ‘vue-router’Vue.use(Router);export default new Router(&#123; routes: [ &#123; path: ‘/user/:name’, name: ‘user’, component: User &#125; &#123; path: ‘/’, redirect: ‘/goods’(映射两个地址的关系) &#125; ]&#125;) 路由的使用(相当于是a链接)，绑定to来传递数据 12&lt;router-link :to=“&#123;name:’user’, params: &#123;name:...&#125;&#125;”&gt;&lt;/router-link&gt; 在要切换路由的位置使用router-view进行配合的 1&lt;router-view&gt;&lt;/router-view&gt; 其他 12//返回上一页面this.$router.go(-1) 12//等同于&lt;router-link&gt;this.$router.push(&#123;name:'article',params: &#123; &#125;&#125;) 三. vue-resourcevue-resource添加vue-resource组件 123import VueResource from ‘vue-resource’Vue.use(VueResource); 使用： 12this.$http.get(‘/goods’) .then(...) axiosvue-ressource的下一代产品 1234import VueAxios from ‘vue-axios’import axios from ‘axios’Vue.use(VueAxios,axios) 使用： 1234this.axios.get(‘https://...’) .then(result =&gt; &#123; ... &#125;)this.axios.post(‘https://’,&#123;accesstoken: this.ak&#125;) .then(result =&gt; &#123; ... &#125;) 四. vuex组件之间多通信时使用 123456789101112131415161718import Vuex from ‘vuex’vue.use(Vuex);const store = new Vuex.Store(&#123; state: &#123; tab: ‘all’ &#125;, mutations: &#123; changeTab(state,payload) &#123; state.tab = … &#125; &#125;&#125;)new Vue(&#123; el: '#app', store, template: '&lt;App/&gt;', components: &#123; App &#125;&#125;) 在组件中使用 12this.$store.state.tab;this.$store.commit.(‘changeTab’,&#123; 传参 &#125;) 五. vue的属性12345678910props: &#123;&#125;computed: &#123;&#125;methods: &#123;&#125;components: &#123;&#125;filters: &#123;&#125;watch: &#123; ‘seller’() &#123;&#125;&#125;data() &#123;&#125;created() &#123;&#125;mounted() &#123;&#125; 注意这里只有data和生命周期的钩子函数使用函数形式。 六、父子组件传递数据 父to子父组件中： 1v-bind:属性名=“ ”（简写为 :food=“food”） 子组件： 1props获取 子to父 子组件：1$emit('add',event.target) 父组件： 1v-on(简写为@add=“addFood”) 七、其他DOM更新完成之后执行 1this.$nextTick(() =&gt; &#123; &#125;);","categories":[{"name":"Vue","slug":"Vue","permalink":"http://www.qirenji.info/categories/Vue/"},{"name":"JavaScript","slug":"Vue/JavaScript","permalink":"http://www.qirenji.info/categories/Vue/JavaScript/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://www.qirenji.info/tags/Vue/"}]},{"title":"Vue.js打造的GitHub排行榜","slug":"Vue-js打造的GitHub排行榜","date":"2017-07-20T02:56:30.000Z","updated":"2017-08-28T02:58:28.000Z","comments":true,"path":"2017/07/20/Vue-js打造的GitHub排行榜/","link":"","permalink":"http://www.qirenji.info/2017/07/20/Vue-js打造的GitHub排行榜/","excerpt":"","text":"Vue.js打造的GitHub排行榜前言爬虫简单小练习，利用Node js对github项目进行爬虫，对github各种类项目进行按🌟star数目进行排序。 Github地址：https://github.com/qirenji/github-ranking 实现功能 [x] github爬取 – 完成 [x] 项目主页显示 – 完成 [x] 项目切换 – 完成 预览在线预览地址 👉 http://60.205.181.124:18001/ 首页 首页 侧边栏项目切换 文章详情页 技术栈 Vue2.0：前端页面展示。 Vue-cli：vue手脚架工具。 axios：向后端发起请求。 cheerio：快速、灵活、实施的jQuery核心实现，抓取页面内容很方便。 ES6：箭头函数、promise等语法很好用。 Webpack：vue-cli自带Webpack，添加sass相关loader，其他vue-cli已经配置好了webpack，你只需要安装依赖就可以，使用的时候只需要。 SASS(SCSS)：用SCSS做CSS预处理语言。 flex：flex弹性布局，简单适配手机、PC端。 CSS3：CSS3过渡动画及样式。 总结 每次现爬取github等待时间较长，可以使用缓冲，加快访问速度。使用json数据文件存到服务器，等有用户访问的时候读取该文件，活着使用redis缓存工具来解决此问题。 异步操作很好用，但也容易出错！熟练掌握Promis等方法，提高效率。 About关于我: http://www.qirenji.info/about GitHub: https://github.com/qirenji/ E-mail: lyf@qirenji.com","categories":[{"name":"Vue","slug":"Vue","permalink":"http://www.qirenji.info/categories/Vue/"},{"name":"实战项目","slug":"Vue/实战项目","permalink":"http://www.qirenji.info/categories/Vue/实战项目/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://www.qirenji.info/tags/Vue/"},{"name":"Github排行榜","slug":"Github排行榜","permalink":"http://www.qirenji.info/tags/Github排行榜/"}]},{"title":"Vue项目部署阿里云","slug":"Vue项目部署阿里云","date":"2017-07-19T14:06:29.000Z","updated":"2017-07-20T14:12:10.000Z","comments":true,"path":"2017/07/19/Vue项目部署阿里云/","link":"","permalink":"http://www.qirenji.info/2017/07/19/Vue项目部署阿里云/","excerpt":"","text":"Vue项目部署到阿里云服务器文章适合初学vue项目想部署到服务上的。 一、文件准备首先准备好要发布的前后台文件 前端文件如是使用vue-cli搭建，在vue项目中使用如下命令生成 1npm run build 可以看到在本地多出来一个dist文件，此文件为压缩后文件，可直接部署到服务器 后端文件可以简单编写一个，或由后端同学提供这里给出一个nodejs的小例子： 12345678910111213141516171819var express = require('express');var fs = require('fs')var port = process.env.PORT || 3000;var app = express();app.use(express.static('./dist'));app.get(\"/\",function(req,res)&#123; res.render('index.html',&#123;&#125;)&#125;)module.exports = app.listen(port, function (err) &#123; if (err) &#123; console.log(err); return &#125; console.log('Listening at http://localhost:' + port + '\\n')&#125;); 这里后端端口号使用3000端口。 二. 关联文件 把前后端文件放入一个文件夹中，添加至github或码云等仓库 在git上添加服务器和本地的ssh。 服务器和本地都需安装pm2 1npm install pm2 -g 这样就可以通过github把本地和服务器关联起来。 在服务器端的/www文件夹下，创建项目文件夹，并修改其权限，简单简单修改为 123cd /wwwsudo chmod 777 cnode 三. 修改阿里云安全组登陆到阿里云服务器管理页面，找到安全组，添加项目中所需要的安全组的端口号。 四. 修改服务器防火墙12//修改防火墙 sudo vi /etc/iptables.up.rules 12//重启防火墙sudo iptables-restore &lt; /etc/iptables.up.rules 五. 编写ecosystem文件本地编写ecosystem.json文件。如下 1234567891011121314151617181920212223242526272829&#123; \"apps\": [ &#123; \"name\": \"cnode\", \"script\": \"server.js\", \"env\": &#123; \"COMMON_VARIABLE\": \"true\" &#125;, \"env_production\": &#123; \"NODE_ENV\": \"production\" &#125; &#125; ], \"deploy\": &#123; \"production\": &#123; \"user\": \"服务器用户名\", \"host\": [\"你的服务器ip\"], \"port\": \"服务器端口号\", \"ref\": \"origin/master\", \"repo\": \"gtihub或码云的对应项目ssh地址\", \"path\": \"/www/cnode/production\", \"ssh_options\": \"StrictHostKeyChecking=no\", \"post-deploy\": \"npm install --registry=https://registry.npm.taobao.org &amp;&amp; pm2 startOrRestart ecosystem.json --env production\", \"env\": &#123; \"NODE_ENV\": \"production\" &#125; &#125; &#125;&#125; 然后本地执行 1pm2 deploy ecosystem.json production resetup 看到Success说明部署成功。 以后每次服务器更新只需提交到github执行上述代码即可","categories":[{"name":"建站","slug":"建站","permalink":"http://www.qirenji.info/categories/建站/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://www.qirenji.info/tags/Vue/"},{"name":"项目部署","slug":"项目部署","permalink":"http://www.qirenji.info/tags/项目部署/"}]},{"title":"hexo搭建github个人博客","slug":"hexo搭建github个人博客","date":"2017-07-18T15:41:11.000Z","updated":"2017-07-19T14:33:19.000Z","comments":true,"path":"2017/07/18/hexo搭建github个人博客/","link":"","permalink":"http://www.qirenji.info/2017/07/18/hexo搭建github个人博客/","excerpt":"","text":"用Hexo 3 搭建github blog本文使用的是Mac进行演示，如过是windows系统方式基本相同，单具体安装步骤请自行百度。 一. 注册github账号点击gitbub官方网站进行注册 创建仓库注册完成后点击github首页上的➕New repository创建仓库 image 创建的Repository name有固定的格式1你的github昵称.github.io 点击Creat repository即可创建仓库 生成添加秘钥打开终端输入： 1ssh-keygen -t rsa -C \"Github的注册邮箱地址\" 一路Enter过来就好，待秘钥生成完毕，会得到两个文件id_rsa和id_rsa.pub 1cat ~/.ssh/id_rsa.pub 查看公钥并复制其内容。 http://github.com/settings/ssh New SSH key输入一个Title把刚才查看到的公钥输入到Key上，生成SSH key。 二.node.js 和git安装进入node.js官网，下载并安装即可，推荐安装新版。 git安装可用过homebrew安装，首先安装homebrew 1ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\" 然后安装git 1brew install git 三.安装hexo强调一下，这一步使我们搭建博客的核心，是重中之重。 安装hexo1$ npm install -g hexo-cli 安装好之后，终端输入 1$ hexo 若出现下图，说明hexo安装成功 image 初始化博客着到你创建博客的目录，创建博客文件夹 123456// 创建博客文件夹，并初始化博客$ hexo init &lt;folder&gt;//进入博客文件夹$ cd &lt;folder&gt;//安装所有的依赖包$ npm install 四.修改博客主题和配置 先下载主题到themes文件夹中 修改_config.yml文件中themes项为自己的主题名 修改_config.yml文件中的deploy项如下 1234deploy: type: git repo: https://github.com/你的昵称/你的昵称.github.io.git branch: master 五.新建文章并发布在博客根文件夹下 1$ hexo n \"文章名称\" 可以看到在source/_post/文件夹看到新建的.md文件可以在其结尾处添加一些内容，方便我们测试。输入1$ hexo g 生成我们要发布的文件，在发布之前我们可以通过 1$ hexo s 然后打开浏览器输入localhost:4000,查看文章。现在只是在本地跑起来来，还需要把程序托管到github上。 首先来到 https://github.com/你的昵称/你的昵称.github.io/settings 进行github pages页进行设置，选择source为master分支，点击save即可 image 1234//安装hexo git插件$ npm install hexo-deployer-git --save//部署到github$ hexo g 这样就可通过 你的昵称.github.io 来访问我们的博客了 六.关联域名首先去万网，godaddy等域名系统来购买一个域名。这里我买的是godaddy的域名。购买完成后进入到 管理DNS 关联github 然后再去github pages页设置Custom domain选项为你买的域名。关联成功后等待几分钟，就可以通过域名访问你的hexo博客来。 七.其他123456hexo常用命令hexo n \"我的博客\"==hexo new \"我的博客\"#新建文章hexo p==hexo publishhexo g==hexo generate#生成hexo s==hexo server#启动服务预览hexo d==hexo deploy#部署","categories":[{"name":"建站","slug":"建站","permalink":"http://www.qirenji.info/categories/建站/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://www.qirenji.info/tags/hexo/"},{"name":"个人博客","slug":"个人博客","permalink":"http://www.qirenji.info/tags/个人博客/"}]}]}