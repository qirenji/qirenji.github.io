{"meta":{"title":"一抹阳光 - qirenji.info","subtitle":"IT技术分享","description":"天才在于积累，聪明在于勤奋。","author":"Qi Renji","url":"http://www.qirenji.info"},"pages":[{"title":"关于我","date":"2017-07-18T09:00:30.000Z","updated":"2017-07-18T09:00:30.000Z","comments":false,"path":"about/index.html","permalink":"http://www.qirenji.info/about/index.html","excerpt":"","text":"Quick Start我是测试文字 Create a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment"},{"title":"","date":"2017-07-18T08:47:31.000Z","updated":"2017-07-18T08:47:31.000Z","comments":false,"path":"categories/index.html","permalink":"http://www.qirenji.info/categories/index.html","excerpt":"","text":""},{"title":"网络资料收集","date":"2017-08-08T06:02:44.000Z","updated":"2017-08-08T06:02:44.000Z","comments":false,"path":"collection/index.html","permalink":"http://www.qirenji.info/collection/index.html","excerpt":"","text":"Nginx能用来做什么 张鑫旭blog 阮一峰blog w3school 菜鸟教程 css88 jQuery中文文档 Bootstrap中文文档 ES6语法 Webpack2.x文档 Vue文档 NodeJs API文档 Express文档"},{"title":"","date":"2017-07-18T06:39:44.000Z","updated":"2017-07-18T06:39:44.000Z","comments":false,"path":"tags/index.html","permalink":"http://www.qirenji.info/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"城市选择器插件（三级联动）","slug":"城市选择器插件（三级联动）","date":"2017-08-08T14:49:20.000Z","updated":"2017-08-09T01:40:01.000Z","comments":true,"path":"2017/08/08/城市选择器插件（三级联动）/","link":"","permalink":"http://www.qirenji.info/2017/08/08/城市选择器插件（三级联动）/","excerpt":"","text":"城市选择器(三级联动)介绍一个中国地区的三级联动数据，也可以自定义数据。 使用默认数据引入js文件。在html文件中插入1&lt;script src=\"./dist/all.js\"&gt;&lt;/script&gt;， 然后1&lt;script&gt;new Select()&lt;/script&gt; 默认就可以生成中国地区的三级联动数据啦 自定义数据1new Select('.container', data, text); 第一个参数是插件所在的父容器 第二个参数是插件所要选择的数据（json形式） 第三个参数是选择器前面的提示词语示例1234567891011121314151617181920212223242526272829303132333435&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width,initial-scale=1.0,user-scalable=no\"&gt; &lt;title&gt;地区选择组件&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"container\"&gt; &lt;/div&gt; &lt;!-- &lt;script src=\"js/data.js\"&gt;&lt;/script&gt; &lt;script src=\"js/select-plugin-oop.js\"&gt;&lt;/script&gt; --&gt; &lt;script src=\"dist/all.js\"&gt;&lt;/script&gt; &lt;script&gt; const text = ['选项1','选项二','选项三'] //自定义数据 const data = &#123; 'province': ['a1', 'a2', 'a3'], 'city': [ ['a11', 'a12', 'a13'], ['a21', 'a22'], ['a31', 'a32'] ], 'county': [ [['a111', 'a112'], ['a121', 'a122'], ['a131', 'a132']], [['a211', 'a212'], ['a221', 'a222']], [['a311'], ['a312']] ] &#125;; let selector = new Select('.container',data,text); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 效果图 效果图 github地址: https://github.com/qirenji/select-plugin","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.qirenji.info/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.qirenji.info/tags/JavaScript/"},{"name":"插件","slug":"插件","permalink":"http://www.qirenji.info/tags/插件/"}]},{"title":"gulp执行顺序(gulp-sequence)","slug":"gulp执行顺序-gulp-sequence","date":"2017-08-02T02:40:23.000Z","updated":"2017-08-25T02:43:04.000Z","comments":true,"path":"2017/08/02/gulp执行顺序-gulp-sequence/","link":"","permalink":"http://www.qirenji.info/2017/08/02/gulp执行顺序-gulp-sequence/","excerpt":"","text":"介绍Node.js 工具链中的典型任务运行器有 Grunt ，以及后起之秀 Gulp。 与以传统的方式进行配置的 Grunt 相比， Gulp 则使用“代码”的方式来描述任务。而它们另一个巨大的不同，则体现在运行方式上：Grunt 的运行方式很直观：解析依赖，使用配置逐步运行已定义的任务；而 Gulp 则默认将所有任务和步骤异步化运行。显而易见，Gulp 在效率上是有明显的提升的。 问题上文介绍gulp是异步的，但是当写完一系列任务准备执行时 1gulp.task('build', ['clean', 'styles', 'images', 'scripts'])); 发现终端报错 image 如上图所示，任务完全错乱了，我们是想先执行clean，然后执行scritp和styles等任务。但由于异步操作，导致了执行出错。 当然如果是一个任务，可以使用依赖 1gulp.task('scripts', ['clean'])); 这样就可以在执行clean后执行scripts任务了。 但我们有一系列任务，这时候就可以使用国内的 Teambition 团队开源了 gulp-sequence ，以及国外开发者开发的 run-sequence来完美解决这个问题。 gulp-sequence它们提供了类似的调用方式，下面的代码演示如何使用 gulp-sequence 按顺序地运行多个或多组 Gulp 任务： 123var gulpSequence = require('gulp-sequence'); gulp.task('build', gulpSequence('clean', ['styles', 'images', 'scripts'])); 这样就可以预期的先执行clean再之行其他任务了。 具体终端执行结果如下图 image","categories":[{"name":"工具","slug":"工具","permalink":"http://www.qirenji.info/categories/工具/"},{"name":"gulp","slug":"工具/gulp","permalink":"http://www.qirenji.info/categories/工具/gulp/"}],"tags":[{"name":"gulp","slug":"gulp","permalink":"http://www.qirenji.info/tags/gulp/"},{"name":"自动化工具","slug":"自动化工具","permalink":"http://www.qirenji.info/tags/自动化工具/"}]},{"title":"gulp学习","slug":"gulp学习","date":"2017-07-31T15:31:43.000Z","updated":"2017-08-09T02:38:31.000Z","comments":true,"path":"2017/07/31/gulp学习/","link":"","permalink":"http://www.qirenji.info/2017/07/31/gulp学习/","excerpt":"","text":"glup学习gulpjs是一个前端构建工具，与gruntjs相比，gulpjs无需写一大堆繁杂的配置参数，API也非常简单，学习起来很容易，而且gulpjs使用的是nodejs中stream来读取和操作数据，其速度更快。 安装在项目根目录执行 1234 //全局安装npm install -g gulp //项目使用npm install --save-dev gulp 创建gulpfile.js就像gruntjs需要一个Gruntfile.js文件一样，gulp也需要一个文件作为它的主文件，在gulp中这个文件叫做gulpfile.js 123456此时我们的目录结构是这样子的：├── gulpfile.js├── node_modules│ └── gulp└── package.json 添加的gulpfile.js内容大概是这样的。 1234567891011121314151617//导入工具包 require('node_modules里对应模块')var gulp = require('gulp'), //本地安装gulp所用到的地方 less = require('gulp-less'); //定义一个testLess任务（自定义任务名称）gulp.task('testLess', function () &#123; gulp.src('src/less/index.less') //该任务针对的文件 .pipe(less()) //该任务调用的模块 .pipe(gulp.dest('src/css')); //将会在src/css下生成index.css&#125;); gulp.task('default',['testLess', 'elseTask']); //定义默认任务 elseTask为其他任务，该示例没有定义elseTask任务 //gulp.task(name[, deps], fn) 定义任务 name：任务名称 deps：依赖任务名称 fn：回调函数//gulp.src(globs[, options]) 执行任务处理的文件 globs：处理的文件路径(字符串或者字符串数组) //gulp.dest(path[, options]) 处理完后文件生成路径//gulp.watch(glob [, opts], tasks) 监视文件，并且可以在文件发生改动时候做一些事情。 运行glup 1gulp task1 常用插件自动加载插件gulp-load-plugins这个插件能自动帮你加载package.json文件里的gulp插件。 123var gulp = require('gulp');//加载gulp-load-plugins插件，并马上运行它var plugins = require('gulp-load-plugins')(); 注意必须要保证你需要自动加载的插件已经写入到了package.json文件里 重命名gulp-rename 用来重命名文件流中的文件。 12345678910var gulp = require('gulp'), rename = require('gulp-rename'), uglify = require(\"gulp-uglify\"); gulp.task('rename', function () &#123; gulp.src('js/jquery.js') .pipe(uglify()) //压缩 .pipe(rename('jquery.min.js')) //会将jquery.js重命名为jquery.min.js .pipe(gulp.dest('js'));&#125;); ES6文件转换gulp-babel 用来转换ES6或ES7 需要安装babel-preset-es2015插件，才能把es6编译成es512345678910var gulp = require(\"gulp\");var babel = require(\"gulp-babel\");gulp.task(\"default\", function () &#123; return gulp.src(\"src/app.js\") .pipe(babel(&#123; presets: ['es2015'] &#125;)) .pipe(gulp.dest(\"dist\"));&#125;); js文件压缩gulp-uglify 用来压缩js文件，使用的是uglify引擎 12345678var gulp = require('gulp'), uglify = require(\"gulp-uglify\"); gulp.task('minify-js', function () &#123; gulp.src('js/*.js') // 要压缩的js文件 .pipe(uglify()) //使用uglify进行压缩,更多配置请参考： .pipe(gulp.dest('dist/js')); //压缩后的路径&#125;); css文件压缩gulp-minify-css 要压缩css文件时可以使用该插件 12345678var gulp = require('gulp'), minifyCss = require(\"gulp-minify-css\"); gulp.task('minify-css', function () &#123; gulp.src('css/*.css') // 要压缩的css文件 .pipe(minifyCss()) //压缩css .pipe(gulp.dest('dist/css'));&#125;); html文件压缩gulp-minify-html 12345678var gulp = require('gulp'), minifyHtml = require(\"gulp-minify-html\"); gulp.task('minify-html', function () &#123; gulp.src('html/*.html') // 要压缩的html文件 .pipe(minifyHtml()) //压缩 .pipe(gulp.dest('dist/html'));&#125;); js代码检查gulp-jshint 12345678var gulp = require('gulp'), jshint = require(\"gulp-jshint\"); gulp.task('jsLint', function () &#123; gulp.src('js/*.js') .pipe(jshint()) .pipe(jshint.reporter()); // 输出检查结果&#125;); 文件合并gulp-concat 12345678var gulp = require('gulp'), concat = require(\"gulp-concat\"); gulp.task('concat', function () &#123; gulp.src('js/*.js') //要合并的文件 .pipe(concat('all.js')) // 合并匹配到的js文件并命名为 \"all.js\" .pipe(gulp.dest('dist/js'));&#125;); less和sass的编译less使用gulp-less 12345678var gulp = require('gulp'), less = require(\"gulp-less\"); gulp.task('compile-less', function () &#123; gulp.src('less/*.less') .pipe(less()) .pipe(gulp.dest('dist/css'));&#125;); sass使用gulp-sass 12345678var gulp = require('gulp'), sass = require(\"gulp-sass\"); gulp.task('compile-sass', function () &#123; gulp.src('sass/*.sass') .pipe(sass()) .pipe(gulp.dest('dist/css'));&#125;); 图片压缩gulp-imagemin插件来压缩jpg、png、gif等图片 123456789101112var gulp = require('gulp');var imagemin = require('gulp-imagemin');var pngquant = require('imagemin-pngquant'); //png图片压缩插件gulp.task('default', function () &#123; gulp.src('src/images/*') .pipe(imagemin(&#123; progressive: true, use: [pngquant()] //使用pngquant来压缩png图片 &#125;)) .pipe(gulp.dest('dist'));&#125;); gulp-imagemin的使用比较复杂一点，而且它本身也有很多插件，建议去它的项目主页看看文档。 自动化gulp-livereload该插件最好配合谷歌浏览器来使用，且要安装livereload chrome extension扩展插件 123456789101112131415var gulp = require('gulp'), less = require('gulp-less'), livereload = require('gulp-livereload');gulp.task('less', function() &#123; gulp.src('less/*.less') .pipe(less()) .pipe(gulp.dest('css')) .pipe(livereload());&#125;);gulp.task('watch', function() &#123; livereload.listen(); //要在这里调用listen()方法 gulp.watch('less/*.less', ['less']);&#125;); browser-sync12345678910111213141516171819var gulp = require('gulp');var browserSync = require('browser-sync').create(); gulp.task('js-watch', ['js'], browserSync.reload);// 使用默认任务启动Browsersync，监听JS文件gulp.task('default', ['js'], function () &#123; // 从这个项目的根目录启动服务器 browserSync.init(&#123; server: &#123; baseDir: \"./\" &#125; &#125;); // 添加 browserSync.reload 到任务队列里 // 所有的浏览器重载后任务完成。 gulp.watch(\"js/*.js\", ['js-watch']);&#125;); 实例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778var gulp = require('gulp');var browsersync = require('browser-sync').create();//删除dist目录下文件var del=require('del');gulp.task('clean',function(cb)&#123; return del(['dist/*'],cb);&#125;)//操作js文件var uglify = require('gulp-uglify');var concat = require('gulp-concat');var babel = require('gulp-babel');var babeles2015 = require('babel-preset-es2015');gulp.task('js',function()&#123; gulp.src('src/js/*.js') .pipe(babel(&#123; presets: ['es2015'] &#125;)) .pipe(concat('all.js')) .pipe(uglify()) .pipe(gulp.dest('dist/js')) .pipe(browsersync.stream()); //文件有更新自动执行&#125;)//操作css文件var cssnano = require('gulp-cssnano');//css压缩插件// var less=require('gulp-less');//less文件编译gulp.task('css', function() &#123; gulp.src('src/css/*.css') // .pipe(less()) //编译less文件 .pipe(cssnano())//css压缩 .pipe(gulp.dest('dist/css')) .pipe(browsersync.stream());&#125;);var htmlmin = require('gulp-htmlmin'); //html压缩插件gulp.task('html', function() &#123; gulp.src('src/*.html') .pipe(htmlmin(&#123; //压缩html collapseWhitespace: true, //省略布尔属性的值 collapseBooleanAttributes: true, //清除html注释 removeComments: true, //删除所有空格作为属性值 removeEmptyAttributes: true, //删除type=text/javascript removeScriptTypeAttributes: true, //删除type=text/css removeStyleLinkTypeAttributes: true, //压缩页面js minifyJS:true, //压缩页面css minifyCSS:true &#125;)) .pipe(gulp.dest('dist')) .pipe(browsersync.stream());&#125;);gulp.task('serve', ['clean'], function() &#123; gulp.start('js','css','html'); browsersync.init(&#123; port: 3000, server: &#123; baseDir: ['dist'] &#125; &#125;); gulp.watch('src/js/*.js', ['js']); //监控文件变化，自动更新 gulp.watch('src/css/*.css', ['css']); gulp.watch('src/*.html', ['html']);&#125;);gulp.task('default',['serve']); gulp学习资料 Gulp：任务自动管理工具 gulp plugins 插件介绍 https://github.com/gulpjs/gulp Browsersync / 说明文档","categories":[{"name":"工具","slug":"工具","permalink":"http://www.qirenji.info/categories/工具/"},{"name":"gulp","slug":"工具/gulp","permalink":"http://www.qirenji.info/categories/工具/gulp/"}],"tags":[{"name":"gulp","slug":"gulp","permalink":"http://www.qirenji.info/tags/gulp/"},{"name":"自动化工具","slug":"自动化工具","permalink":"http://www.qirenji.info/tags/自动化工具/"}]},{"title":"webpack学习","slug":"webpack学习","date":"2017-07-29T15:50:25.000Z","updated":"2017-07-30T15:52:32.000Z","comments":true,"path":"2017/07/29/webpack学习/","link":"","permalink":"http://www.qirenji.info/2017/07/29/webpack学习/","excerpt":"","text":"webpack学习webpack室一款模块加载器兼打包工具，它能把各种资源，例如JS、样式（含less/sass）、图片等都作为模块来使用和处理。 webpack不同于gulp和grunt。 gulp是工具链、构建工具，可以配合各种插件做js压缩，css压缩，less编译 替代手工实现自动化的工具 1.构建工具 2.自动化 3.提高效率用 webpack是文件打包工具，可以把项目的各种js文、css文件等打包合并成一个或多个文件，主要用于模块化方案，预编译模块的方案。 1.打包工具 2.模块化识别 3.编译模块代码方案用 webpack的官网是 http://webpack.github.io/ ，文档地址是 http://webpack.github.io/docs/ 。 webpack主要有4大核心概念 Entryentry 是页面入口文件配置，其语法大致为： 123456&#123; entry: &#123; page1: \"./page1\", page2: [\"./entry1\", \"./entry2\"] &#125;&#125; outputoutput 是对应输出项配置（即入口文件最终要生成什么名字的文件、存放到哪里） 1234output: &#123; path: \"dist/js/page\", filename: \"[name].bundle.js\" &#125; module.loaders module.loaders 是最关键的一块配置。它告知 webpack 每一种文件都需要使用什么加载器来处理： 12345678910111213module: &#123; //加载器配置 loaders: [ //.css 文件使用 style-loader 和 css-loader 来处理 &#123; test: /\\.css$/, loader: 'style-loader!css-loader' &#125;, //.js 文件使用 jsx-loader 来编译处理 &#123; test: /\\.js$/, loader: 'jsx-loader?harmony' &#125;, //.scss 文件使用 style-loader、css-loader 和 sass-loader 来编译处理 &#123; test: /\\.scss$/, loader: 'style!css!sass?sourceMap'&#125;, //图片文件使用 url-loader 来处理，小于8kb的直接转为base64 &#123; test: /\\.(png|jpg)$/, loader: 'url-loader?limit=8192'&#125; ] &#125; PluginsLoaders是以单个文件为基础对文件进行操作，而Plugins与Loaders不同的是，Plugins是对整体进行操作。 使用插件，你只需要将其进行引入到配置文件并添加到plugins数组中，大多数的插件都是可通过选项进行配置。 1234plugins: [ new webpack.optimize.UglifyJsPlugin(), //丑化压缩JS new HtmlWebpackPlugin(&#123;template: './src/index.html'&#125;) //生成HTML模板 ] 如需了解更多，请跳转址webpack中文教程。","categories":[{"name":"webpack","slug":"webpack","permalink":"http://www.qirenji.info/categories/webpack/"},{"name":"工具","slug":"webpack/工具","permalink":"http://www.qirenji.info/categories/webpack/工具/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"http://www.qirenji.info/tags/webpack/"},{"name":"打包工具","slug":"打包工具","permalink":"http://www.qirenji.info/tags/打包工具/"}]},{"title":"nginx学习","slug":"nginx学习","date":"2017-07-26T14:04:29.000Z","updated":"2017-07-26T14:05:42.000Z","comments":true,"path":"2017/07/26/nginx学习/","link":"","permalink":"http://www.qirenji.info/2017/07/26/nginx学习/","excerpt":"","text":"ngix学习静态HTTP服务器首先，Nginx是一个HTTP服务器，可以将服务器上的静态文件（如HTML、图片）通过HTTP协议展现给客户端。 123456server &#123; listen 80; # 端口号 location / &#123; root /usr/share/nginx/html; # 静态文件路径 &#125;&#125; 反向代理服务器客户端本来可以直接通过HTTP协议访问某网站应用服务器，如果网站管理员在中间加上一个Nginx，客户端请求Nginx，Nginx请求应用服务器，然后将结果返回给客户端，此时Nginx就是反向代理服务器。 12345listen 80; location / &#123; proxy_pass http://192.168.20.1:8080; # 应用服务器HTTP地址 &#125;&#125; 负载均衡当网站访问量非常大，网站站长开心赚钱的同时，也摊上事儿了。因为网站越来越慢，一台服务器已经不够用了。于是将相同的应用部署在多台服务器上，将大量用户的请求分配给多台机器处理。同时带来的好处是，其中一台服务器万一挂了，只要还有其他服务器正常运行，就不会影响用户使用。 Nginx可以通过反向代理来实现负载均衡。 12345678910upstream myapp &#123; server 192.168.20.1:8080; # 应用服务器1 server 192.168.20.2:8080; # 应用服务器2&#125;server &#123; listen 80; location / &#123; proxy_pass http://myapp; &#125;&#125; 虚拟主机网站访问量大，需要负载均衡。然而并不是所有网站都如此出色，有的网站，由于访问量太小，需要节省成本，将多个网站部署在同一台服务器上。例如将www.aaa.com和www.bbb.com两个网站部署在同一台服务器上，两个域名解析到同一个IP地址，但是用户通过两个域名却可以打开两个完全不同的网站，互相不影响，就像访问两个服务器一样，所以叫两个虚拟主机。 12345678910111213141516171819server &#123; listen 80 default_server; server_name _; return 444; # 过滤其他域名的请求，返回444状态码&#125;server &#123; listen 80; server_name www.aaa.com; # www.aaa.com域名 location / &#123; proxy_pass http://localhost:8080; # 对应端口号8080 &#125;&#125;server &#123; listen 80; server_name www.bbb.com; # www.bbb.com域名 location / &#123; proxy_pass http://localhost:8081; # 对应端口号8081 &#125;&#125; 在服务器8080和8081分别开了一个应用，客户端通过不同的域名访问，根据server_name可以反向代理到对应的应用服务器。","categories":[{"name":"服务器","slug":"服务器","permalink":"http://www.qirenji.info/categories/服务器/"},{"name":"Nginx","slug":"服务器/Nginx","permalink":"http://www.qirenji.info/categories/服务器/Nginx/"}],"tags":[{"name":"Nginx","slug":"Nginx","permalink":"http://www.qirenji.info/tags/Nginx/"}]},{"title":"git提交到多个远程仓库","slug":"git提交到多个远程仓库","date":"2017-07-25T03:11:05.000Z","updated":"2017-08-25T03:12:13.000Z","comments":true,"path":"2017/07/25/git提交到多个远程仓库/","link":"","permalink":"http://www.qirenji.info/2017/07/25/git提交到多个远程仓库/","excerpt":"","text":"问题分别有仓库A（github）,B（码云的git），本机为C。 假设以 a 仓库作为最终的使用仓库， b为发布仓库，想两个仓库一起使用，怎么用呢？ 增加远程仓库1234#添加githubgit remote add origin https://github.com/xxx(仓库地址)#添加oschinagit remote set-url --add origin https://git.oschina.net/xxxx(仓库地址) 提交1git push origin --all 这样就可以把本机的代码提交两个仓库了。 但是如果两个仓库都有内容。那么问题来了： 怎么才能把两个远程仓库代码同步？以便以后可以代码同时推送到这两个仓库。 直接在命令行敲： 123git push -f origin --all 注释： origin 远程仓库名， master 分支名， -f 为force，意为：强行、强制。 当然不止这一种操作方式了，但是这种操作是最快速的，不会有冲突什么。 ⚠️：这个-f命令请谨慎使用：请谨慎使用！请谨慎使用！请谨慎使用！ 毕竟数据无价，如果被覆盖后，就不那么好恢复了。","categories":[{"name":"远程管理","slug":"远程管理","permalink":"http://www.qirenji.info/categories/远程管理/"}],"tags":[{"name":"git","slug":"git","permalink":"http://www.qirenji.info/tags/git/"},{"name":"远程管理","slug":"远程管理","permalink":"http://www.qirenji.info/tags/远程管理/"}]},{"title":"flex布局学习","slug":"flex布局学习","date":"2017-07-24T14:54:39.000Z","updated":"2017-07-24T14:55:49.000Z","comments":true,"path":"2017/07/24/flex布局学习/","link":"","permalink":"http://www.qirenji.info/2017/07/24/flex布局学习/","excerpt":"","text":"Flex布局基本概念Flex意为弹性布局，用来为盒模型提供最大的灵活性。设置为Flex布局之后，float、clear和vertical-align属性将失效。 使用Flex布局，首先要设置父容器为 1display: flex; 这样就可以使用 1justify-content: center; 实现水平居中 1align-items: center; 实现垂直居中。 容器的属性以下6个属性设置在容器上。 flex-direction flex-wrap flex-flow justify-content align-items align-contentflex-direction属性flex-direction属性决定主轴的方向（即项目的排列方向）。 123.flex-box&#123; flex-direction: row | row-reverse | column | column-reverse; &#125; row（默认值）：主轴为水平方向，起点在左端。 row-reverse：主轴为水平方向，起点在右端。 column：主轴为垂直方向，起点在上沿。 column-reverse：主轴为垂直方向，起点在下沿。 flex-wrap属性flex-wrap属性定义，如果一条轴线排不下，如何换行。 123.flex-box&#123; flex-wrap: nowrap | wrap | wrap-reverse;&#125; nowrap ：默认，不换行 wrap ：换行，第一行在上方 wrap-reverse：换行，第一行在下方 flex-flow属性flex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。 123.flex-box &#123; flex-flow: &lt;flex-direction&gt; || &lt;flex-wrap&gt;;&#125; justify-content属性justify-content属性定义了项目在主轴上的对齐方式。 123.flex-box &#123; justify-content: flex-start | flex-end | center | space-between | space-around;&#125; 它可能取5个值，具体对齐方式与轴的方向有关。下面假设主轴为从左到右。 flex-start（默认值）：左对齐 flex-end：右对齐 center： 居中 space-between：两端对齐，项目之间的间隔都相等。 space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。 align-items属性123.flex-box &#123; align-items: flex-start | flex-end | center | baseline | stretch;&#125; 它可能取5个值。具体的对齐方式与交叉轴的方向有关，下面假设交叉轴从上到下。 flex-start：交叉轴的起点对齐。 flex-end：交叉轴的终点对齐。 center：交叉轴的中点对齐。 baseline:项目的第一行文字的基线对齐。 stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。align-content属性 123.flex-box &#123; align-content: flex-start | flex-end | center | space-between | space-around | stretch;&#125; flex-start：与交叉轴的起点对齐。 flex-end：与交叉轴的终点对齐。 center：与交叉轴的中点对齐。 space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。 space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。 stretch（默认值）：轴线占满整个交叉轴(如果项目未设置高度或设为auto时，并且align-item连用，否则失效）) 项目中常用属性首先父级使用 1display：flex 1按比例分配 1flex：n 分配固定像素1flex: 0 0 200px。 来分配200像素的空间。 分配方向默认是水平分配，如需垂直分配，则使用 1flex-direction: column 子项水平居中1justify-content: center 子项垂直居中1align-items: center; 如需学习更多有关flex的相关知识，可去菜鸟教程和阮一峰老师的博客。","categories":[{"name":"CSS3","slug":"CSS3","permalink":"http://www.qirenji.info/categories/CSS3/"}],"tags":[{"name":"flex","slug":"flex","permalink":"http://www.qirenji.info/tags/flex/"},{"name":"CSS3","slug":"CSS3","permalink":"http://www.qirenji.info/tags/CSS3/"}]},{"title":"git常用命令","slug":"git常用命令","date":"2017-07-22T13:48:13.000Z","updated":"2017-07-22T13:49:52.000Z","comments":true,"path":"2017/07/22/git常用命令/","link":"","permalink":"http://www.qirenji.info/2017/07/22/git常用命令/","excerpt":"","text":"git常用命令基本命令使用 在当前目录创建Git仓库，会在当前目录创建.git文件夹 1git init 把文件提交到暂存区 1git add ./&lt;path&gt; 提交当前工作空前的修改内容 1git commit -m '注释' 将存储库克隆到本地目录中 1git clone https://github.com/jquery/jquery.git 将本地分支的更新，推送到远程主机。 1git push origin master 从远程获取最新版本并merge到本地 1git pull 相当于git fetch和git merge一起使用 列出详细信息，在每一个名字后面列出其远程url 1git remote -v 在url创建名字为name的仓库12git remote add origin git@git.*/website_node.git 分支管理 创建分支 1git branch dev 切换分支 1git checkout dev 查看当前分支 1git branch 创建并切换分支 1git branch -d dev 解决冲突Git最常用的可能就是多人协作时解决冲突问题。 一般会先push上自己的文件 123git add .git commit -m '注释'git push -u origin branch-name 然后发现推送失败了，这是因为远程的分支和自己的本地推送内容更新，所以需要使用git pull把远程分支与本地合并。 1git pull 如果合并有冲突，则需要在本地解决冲突。 解决冲突之后，再重新git push就能推送成功了。 1git push origin baranch-name 这就是多人协作之解决冲突。 这里也推荐初学者使用 github desktop，毕竟图形化界面使用起来更直观一些。 如需学习更多内容，请参廖雪峰老师的Git教程","categories":[{"name":"远程管理","slug":"远程管理","permalink":"http://www.qirenji.info/categories/远程管理/"}],"tags":[{"name":"git","slug":"git","permalink":"http://www.qirenji.info/tags/git/"},{"name":"远程管理","slug":"远程管理","permalink":"http://www.qirenji.info/tags/远程管理/"}]},{"title":"vue全家桶总结","slug":"vue全家桶总结","date":"2017-07-20T14:09:27.000Z","updated":"2017-07-20T14:15:18.000Z","comments":true,"path":"2017/07/20/vue全家桶总结/","link":"","permalink":"http://www.qirenji.info/2017/07/20/vue全家桶总结/","excerpt":"","text":"vue全家桶学习一. vue-cli(手脚架搭建项目)初始化项目1vue init webpack projectName 然后顺序执行如下命令，可启动vue项目 123cd my-projectnpm installnpm run dev 如项目中使用其他库或组件需 1npm install *** --save-dev 例如使用scss编写软件,需安装sass编译工具 1npm install sass sass-loader node-sass --save-dev 二.vue-routervue-router主要作为程序的路由控制器 使用： main.js中添加router 1234567import router from ‘./router’new Vue(&#123; el: '#app', router, template: '&lt;App/&gt;', components: &#123; App &#125;&#125;) ./router/index.js文件中 12345678910111213141516import Router from ‘vue-router’Vue.use(Router);export default new Router(&#123; routes: [ &#123; path: ‘/user/:name’, name: ‘user’, component: User &#125; &#123; path: ‘/’, redirect: ‘/goods’(映射两个地址的关系) &#125; ]&#125;) 路由的使用(相当于是a链接)，绑定to来传递数据 12&lt;router-link :to=“&#123;name:’user’, params: &#123;name:...&#125;&#125;”&gt;&lt;/router-link&gt; 在要切换路由的位置使用router-view进行配合的 1&lt;router-view&gt;&lt;/router-view&gt; 其他 12//返回上一页面this.$router.go(-1) 12//等同于&lt;router-link&gt;this.$router.push(&#123;name:'article',params: &#123; &#125;&#125;) 三. vue-resourcevue-resource添加vue-resource组件 123import VueResource from ‘vue-resource’Vue.use(VueResource); 使用： 12this.$http.get(‘/goods’) .then(...) axiosvue-ressource的下一代产品 1234import VueAxios from ‘vue-axios’import axios from ‘axios’Vue.use(VueAxios,axios) 使用： 1234this.axios.get(‘https://...’) .then(result =&gt; &#123; ... &#125;)this.axios.post(‘https://’,&#123;accesstoken: this.ak&#125;) .then(result =&gt; &#123; ... &#125;) 四. vuex组件之间多通信时使用 123456789101112131415161718import Vuex from ‘vuex’vue.use(Vuex);const store = new Vuex.Store(&#123; state: &#123; tab: ‘all’ &#125;, mutations: &#123; changeTab(state,payload) &#123; state.tab = … &#125; &#125;&#125;)new Vue(&#123; el: '#app', store, template: '&lt;App/&gt;', components: &#123; App &#125;&#125;) 在组件中使用 12this.$store.state.tab;this.$store.commit.(‘changeTab’,&#123; 传参 &#125;) 五. vue的属性12345678910props: &#123;&#125;computed: &#123;&#125;methods: &#123;&#125;components: &#123;&#125;filters: &#123;&#125;watch: &#123; ‘seller’() &#123;&#125;&#125;data() &#123;&#125;created() &#123;&#125;mounted() &#123;&#125; 注意这里只有data和生命周期的钩子函数使用函数形式。 六、父子组件传递数据 父to子父组件中： 1v-bind:属性名=“ ”（简写为 :food=“food”） 子组件： 1props获取 子to父 子组件：1$emit('add',event.target) 父组件： 1v-on(简写为@add=“addFood”) 七、其他DOM更新完成之后执行 1this.$nextTick(() =&gt; &#123; &#125;);","categories":[{"name":"Vue","slug":"Vue","permalink":"http://www.qirenji.info/categories/Vue/"},{"name":"JavaScript","slug":"Vue/JavaScript","permalink":"http://www.qirenji.info/categories/Vue/JavaScript/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://www.qirenji.info/tags/Vue/"}]},{"title":"Vue项目部署阿里云","slug":"Vue项目部署阿里云","date":"2017-07-19T14:06:29.000Z","updated":"2017-07-20T14:12:10.000Z","comments":true,"path":"2017/07/19/Vue项目部署阿里云/","link":"","permalink":"http://www.qirenji.info/2017/07/19/Vue项目部署阿里云/","excerpt":"","text":"Vue项目部署到阿里云服务器文章适合初学vue项目想部署到服务上的。 一、文件准备首先准备好要发布的前后台文件 前端文件如是使用vue-cli搭建，在vue项目中使用如下命令生成 1npm run build 可以看到在本地多出来一个dist文件，此文件为压缩后文件，可直接部署到服务器 后端文件可以简单编写一个，或由后端同学提供这里给出一个nodejs的小例子： 12345678910111213141516171819var express = require('express');var fs = require('fs')var port = process.env.PORT || 3000;var app = express();app.use(express.static('./dist'));app.get(\"/\",function(req,res)&#123; res.render('index.html',&#123;&#125;)&#125;)module.exports = app.listen(port, function (err) &#123; if (err) &#123; console.log(err); return &#125; console.log('Listening at http://localhost:' + port + '\\n')&#125;); 这里后端端口号使用3000端口。 二. 关联文件 把前后端文件放入一个文件夹中，添加至github或码云等仓库 在git上添加服务器和本地的ssh。 服务器和本地都需安装pm2 1npm install pm2 -g 这样就可以通过github把本地和服务器关联起来。 在服务器端的/www文件夹下，创建项目文件夹，并修改其权限，简单简单修改为 123cd /wwwsudo chmod 777 cnode 三. 修改阿里云安全组登陆到阿里云服务器管理页面，找到安全组，添加项目中所需要的安全组的端口号。 四. 修改服务器防火墙12//修改防火墙 sudo vi /etc/iptables.up.rules 12//重启防火墙sudo iptables-restore &lt; /etc/iptables.up.rules 五. 编写ecosystem文件本地编写ecosystem.json文件。如下 1234567891011121314151617181920212223242526272829&#123; \"apps\": [ &#123; \"name\": \"cnode\", \"script\": \"server.js\", \"env\": &#123; \"COMMON_VARIABLE\": \"true\" &#125;, \"env_production\": &#123; \"NODE_ENV\": \"production\" &#125; &#125; ], \"deploy\": &#123; \"production\": &#123; \"user\": \"服务器用户名\", \"host\": [\"你的服务器ip\"], \"port\": \"服务器端口号\", \"ref\": \"origin/master\", \"repo\": \"gtihub或码云的对应项目ssh地址\", \"path\": \"/www/cnode/production\", \"ssh_options\": \"StrictHostKeyChecking=no\", \"post-deploy\": \"npm install --registry=https://registry.npm.taobao.org &amp;&amp; pm2 startOrRestart ecosystem.json --env production\", \"env\": &#123; \"NODE_ENV\": \"production\" &#125; &#125; &#125;&#125; 然后本地执行 1pm2 deploy ecosystem.json production resetup 看到Success说明部署成功。 以后每次服务器更新只需提交到github执行上述代码即可","categories":[{"name":"建站","slug":"建站","permalink":"http://www.qirenji.info/categories/建站/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://www.qirenji.info/tags/Vue/"},{"name":"项目部署","slug":"项目部署","permalink":"http://www.qirenji.info/tags/项目部署/"}]},{"title":"hexo搭建github个人博客","slug":"hexo搭建github个人博客","date":"2017-07-18T15:41:11.000Z","updated":"2017-07-19T14:33:19.000Z","comments":true,"path":"2017/07/18/hexo搭建github个人博客/","link":"","permalink":"http://www.qirenji.info/2017/07/18/hexo搭建github个人博客/","excerpt":"","text":"用Hexo 3 搭建github blog本文使用的是Mac进行演示，如过是windows系统方式基本相同，单具体安装步骤请自行百度。 一. 注册github账号点击gitbub官方网站进行注册 创建仓库注册完成后点击github首页上的➕New repository创建仓库 image 创建的Repository name有固定的格式1你的github昵称.github.io 点击Creat repository即可创建仓库 生成添加秘钥打开终端输入： 1ssh-keygen -t rsa -C \"Github的注册邮箱地址\" 一路Enter过来就好，待秘钥生成完毕，会得到两个文件id_rsa和id_rsa.pub 1cat ~/.ssh/id_rsa.pub 查看公钥并复制其内容。 http://github.com/settings/ssh New SSH key输入一个Title把刚才查看到的公钥输入到Key上，生成SSH key。 二.node.js 和git安装进入node.js官网，下载并安装即可，推荐安装新版。 git安装可用过homebrew安装，首先安装homebrew 1ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\" 然后安装git 1brew install git 三.安装hexo强调一下，这一步使我们搭建博客的核心，是重中之重。 安装hexo1$ npm install -g hexo-cli 安装好之后，终端输入 1$ hexo 若出现下图，说明hexo安装成功 image 初始化博客着到你创建博客的目录，创建博客文件夹 123456// 创建博客文件夹，并初始化博客$ hexo init &lt;folder&gt;//进入博客文件夹$ cd &lt;folder&gt;//安装所有的依赖包$ npm install 四.修改博客主题和配置 先下载主题到themes文件夹中 修改_config.yml文件中themes项为自己的主题名 修改_config.yml文件中的deploy项如下 1234deploy: type: git repo: https://github.com/你的昵称/你的昵称.github.io.git branch: master 五.新建文章并发布在博客根文件夹下 1$ hexo n \"文章名称\" 可以看到在source/_post/文件夹看到新建的.md文件可以在其结尾处添加一些内容，方便我们测试。输入1$ hexo g 生成我们要发布的文件，在发布之前我们可以通过 1$ hexo s 然后打开浏览器输入localhost:4000,查看文章。现在只是在本地跑起来来，还需要把程序托管到github上。 首先来到 https://github.com/你的昵称/你的昵称.github.io/settings 进行github pages页进行设置，选择source为master分支，点击save即可 image 1234//安装hexo git插件$ npm install hexo-deployer-git --save//部署到github$ hexo g 这样就可通过 你的昵称.github.io 来访问我们的博客了 六.关联域名首先去万网，godaddy等域名系统来购买一个域名。这里我买的是godaddy的域名。购买完成后进入到 管理DNS 关联github 然后再去github pages页设置Custom domain选项为你买的域名。关联成功后等待几分钟，就可以通过域名访问你的hexo博客来。 七.其他123456hexo常用命令hexo n \"我的博客\"==hexo new \"我的博客\"#新建文章hexo p==hexo publishhexo g==hexo generate#生成hexo s==hexo server#启动服务预览hexo d==hexo deploy#部署","categories":[{"name":"建站","slug":"建站","permalink":"http://www.qirenji.info/categories/建站/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://www.qirenji.info/tags/hexo/"},{"name":"个人博客","slug":"个人博客","permalink":"http://www.qirenji.info/tags/个人博客/"}]}]}